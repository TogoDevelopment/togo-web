{"ast":null,"code":"import { createContext as e, useMemo as r, useContext as t, useRef as i, useEffect as n, useState as o, cloneElement as a, useCallback as s, memo as l, createElement as d, Component as u } from \"react\";\nimport c from \"prop-types\";\nimport { TooltipProvider as f, Tooltip as p, useTooltipHandlers as h, TooltipActionsContext as g, TooltipStateContext as m } from \"@nivo/tooltip\";\nimport b from \"lodash/merge\";\nimport y from \"lodash/get\";\nimport v from \"lodash/set\";\nimport { interpolateString as R } from \"d3-interpolate\";\nimport { config as q, useSpring as k, to as _, animated as w } from \"@react-spring/web\";\nimport x from \"lodash/isString\";\nimport { jsx as O, jsxs as C } from \"react/jsx-runtime\";\nimport W from \"lodash/last\";\nimport S from \"lodash/isArray\";\nimport { scaleQuantize as z, scaleOrdinal as P, scaleSequential as T } from \"d3-scale\";\nimport { schemeBrBG as M, schemePRGn as j, schemePiYG as D, schemePuOr as G, schemeRdBu as B, schemeRdGy as L, schemeRdYlBu as I, schemeRdYlGn as Y, schemeSpectral as A, schemeBlues as F, schemeGreens as E, schemeGreys as U, schemeOranges as X, schemePurples as K, schemeReds as H, schemeBuGn as N, schemeBuPu as V, schemeGnBu as J, schemeOrRd as Q, schemePuBuGn as Z, schemePuBu as $, schemePuRd as ee, schemeRdPu as re, schemeYlGnBu as te, schemeYlGn as ie, schemeYlOrBr as ne, schemeYlOrRd as oe, schemeCategory10 as ae, schemeAccent as se, schemeDark2 as le, schemePaired as de, schemePastel1 as ue, schemePastel2 as ce, schemeSet1 as fe, schemeSet2 as pe, schemeSet3 as he, interpolateBrBG as ge, interpolatePRGn as me, interpolatePiYG as be, interpolatePuOr as ye, interpolateRdBu as ve, interpolateRdGy as Re, interpolateRdYlBu as qe, interpolateRdYlGn as ke, interpolateSpectral as _e, interpolateBlues as we, interpolateGreens as xe, interpolateGreys as Oe, interpolateOranges as Ce, interpolatePurples as We, interpolateReds as Se, interpolateViridis as ze, interpolateInferno as Pe, interpolateMagma as Te, interpolatePlasma as Me, interpolateWarm as je, interpolateCool as De, interpolateCubehelixDefault as Ge, interpolateBuGn as Be, interpolateBuPu as Le, interpolateGnBu as Ie, interpolateOrRd as Ye, interpolatePuBuGn as Ae, interpolatePuBu as Fe, interpolatePuRd as Ee, interpolateRdPu as Ue, interpolateYlGnBu as Xe, interpolateYlGn as Ke, interpolateYlOrBr as He, interpolateYlOrRd as Ne, interpolateRainbow as Ve, interpolateSinebow as Je } from \"d3-scale-chromatic\";\nimport Qe from \"lodash/isFunction\";\nimport Ze from \"lodash/without\";\nimport { curveBasis as $e, curveBasisClosed as er, curveBasisOpen as rr, curveBundle as tr, curveCardinal as ir, curveCardinalClosed as nr, curveCardinalOpen as or, curveCatmullRom as ar, curveCatmullRomClosed as sr, curveCatmullRomOpen as lr, curveLinear as dr, curveLinearClosed as ur, curveMonotoneX as cr, curveMonotoneY as fr, curveNatural as pr, curveStep as hr, curveStepAfter as gr, curveStepBefore as mr, stackOrderAscending as br, stackOrderDescending as yr, stackOrderInsideOut as vr, stackOrderNone as Rr, stackOrderReverse as qr, stackOffsetExpand as kr, stackOffsetDiverging as _r, stackOffsetNone as wr, stackOffsetSilhouette as xr, stackOffsetWiggle as Or } from \"d3-shape\";\nimport { format as Cr } from \"d3-format\";\nimport { timeFormat as Wr } from \"d3-time-format\";\nimport { compose as Sr, defaultProps as zr, setPropTypes as Pr, withPropsOnChange as Tr } from \"@nivo/recompose\";\nimport Mr from \"lodash/isEqual\";\nimport jr from \"lodash/isPlainObject\";\nimport Dr from \"lodash/pick\";\n\nfunction Gr() {\n  return Gr = Object.assign || function (e) {\n    for (var r = 1; r < arguments.length; r++) {\n      var t = arguments[r];\n\n      for (var i in t) {\n        Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);\n      }\n    }\n\n    return e;\n  }, Gr.apply(this, arguments);\n}\n\nfunction Br(e, r) {\n  return Br = Object.setPrototypeOf || function (e, r) {\n    return e.__proto__ = r, e;\n  }, Br(e, r);\n}\n\nfunction Lr(e, r) {\n  if (null == e) return {};\n  var t,\n      i,\n      n = {},\n      o = Object.keys(e);\n\n  for (i = 0; i < o.length; i++) {\n    t = o[i], r.indexOf(t) >= 0 || (n[t] = e[t]);\n  }\n\n  return n;\n}\n\nvar Ir = {\n  fill: c.string,\n  fontSize: c.number,\n  fontFamily: c.string\n},\n    Yr = c.shape({\n  domain: c.shape({\n    line: c.shape({\n      stroke: c.string.isRequired,\n      strokeWidth: c.number.isRequired,\n      strokeDasharray: c.string\n    }).isRequired\n  }).isRequired,\n  ticks: c.shape({\n    line: c.shape({\n      stroke: c.string.isRequired,\n      strokeWidth: c.number.isRequired,\n      strokeDasharray: c.string\n    }).isRequired,\n    text: c.shape(Gr({}, Ir)).isRequired\n  }).isRequired,\n  legend: c.shape({\n    text: c.shape(Gr({}, Ir)).isRequired\n  }).isRequired\n}),\n    Ar = c.shape({\n  line: c.shape({\n    stroke: c.string.isRequired,\n    strokeWidth: c.number.isRequired,\n    strokeDasharray: c.string\n  }).isRequired\n}),\n    Fr = c.shape({\n  hidden: c.shape({\n    symbol: c.shape({\n      fill: c.string.isRequired,\n      opacity: c.number\n    }).isRequired,\n    text: c.shape(Gr({}, Ir, {\n      opacity: c.number\n    })).isRequired\n  }).isRequired,\n  text: c.shape(Gr({}, Ir)).isRequired\n}),\n    Er = c.shape({\n  text: c.shape(Gr({}, Ir)).isRequired\n}),\n    Ur = c.shape({\n  text: c.shape(Gr({}, Ir)).isRequired\n}),\n    Xr = c.shape({\n  text: c.shape(Gr({}, Ir)).isRequired\n}),\n    Kr = c.shape({\n  line: c.shape({\n    stroke: c.string.isRequired,\n    strokeWidth: c.number.isRequired,\n    strokeDasharray: c.string\n  }).isRequired\n}),\n    Hr = c.shape({\n  text: c.shape(Gr({}, Ir, {\n    outlineWidth: c.number.isRequired,\n    outlineColor: c.string.isRequired\n  })).isRequired,\n  link: c.shape({\n    stroke: c.string.isRequired,\n    strokeWidth: c.number.isRequired,\n    outlineWidth: c.number.isRequired,\n    outlineColor: c.string.isRequired\n  }).isRequired,\n  outline: c.shape({\n    stroke: c.string.isRequired,\n    strokeWidth: c.number.isRequired,\n    outlineWidth: c.number.isRequired,\n    outlineColor: c.string.isRequired\n  }).isRequired,\n  symbol: c.shape({\n    fill: c.string.isRequired,\n    outlineWidth: c.number.isRequired,\n    outlineColor: c.string.isRequired\n  }).isRequired\n}),\n    Nr = c.shape({\n  background: c.string.isRequired,\n  fontFamily: c.string.isRequired,\n  fontSize: c.number.isRequired,\n  textColor: c.string.isRequired,\n  axis: Yr.isRequired,\n  grid: Ar.isRequired,\n  legends: Fr.isRequired,\n  labels: Er.isRequired,\n  dots: Ur.isRequired,\n  markers: Xr,\n  crosshair: Kr.isRequired,\n  annotations: Hr.isRequired\n}),\n    Vr = {\n  background: \"transparent\",\n  fontFamily: \"sans-serif\",\n  fontSize: 11,\n  textColor: \"#333333\",\n  axis: {\n    domain: {\n      line: {\n        stroke: \"transparent\",\n        strokeWidth: 1\n      }\n    },\n    ticks: {\n      line: {\n        stroke: \"#777777\",\n        strokeWidth: 1\n      },\n      text: {}\n    },\n    legend: {\n      text: {\n        fontSize: 12\n      }\n    }\n  },\n  grid: {\n    line: {\n      stroke: \"#dddddd\",\n      strokeWidth: 1\n    }\n  },\n  legends: {\n    hidden: {\n      symbol: {\n        fill: \"#333333\",\n        opacity: .6\n      },\n      text: {\n        fill: \"#333333\",\n        opacity: .6\n      }\n    },\n    text: {},\n    ticks: {\n      line: {\n        stroke: \"#777777\",\n        strokeWidth: 1\n      },\n      text: {\n        fontSize: 10\n      }\n    },\n    title: {\n      text: {}\n    }\n  },\n  labels: {\n    text: {}\n  },\n  markers: {\n    lineColor: \"#000000\",\n    lineStrokeWidth: 1,\n    text: {}\n  },\n  dots: {\n    text: {}\n  },\n  tooltip: {\n    container: {\n      background: \"white\",\n      color: \"inherit\",\n      fontSize: \"inherit\",\n      borderRadius: \"2px\",\n      boxShadow: \"0 1px 2px rgba(0, 0, 0, 0.25)\",\n      padding: \"5px 9px\"\n    },\n    basic: {\n      whiteSpace: \"pre\",\n      display: \"flex\",\n      alignItems: \"center\"\n    },\n    chip: {\n      marginRight: 7\n    },\n    table: {},\n    tableCell: {\n      padding: \"3px 5px\"\n    },\n    tableCellValue: {\n      fontWeight: \"bold\"\n    }\n  },\n  crosshair: {\n    line: {\n      stroke: \"#000000\",\n      strokeWidth: 1,\n      strokeOpacity: .75,\n      strokeDasharray: \"6 6\"\n    }\n  },\n  annotations: {\n    text: {\n      fontSize: 13,\n      outlineWidth: 2,\n      outlineColor: \"#ffffff\",\n      outlineOpacity: 1\n    },\n    link: {\n      stroke: \"#000000\",\n      strokeWidth: 1,\n      outlineWidth: 2,\n      outlineColor: \"#ffffff\",\n      outlineOpacity: 1\n    },\n    outline: {\n      fill: \"none\",\n      stroke: \"#000000\",\n      strokeWidth: 2,\n      outlineWidth: 2,\n      outlineColor: \"#ffffff\",\n      outlineOpacity: 1\n    },\n    symbol: {\n      fill: \"#000000\",\n      outlineWidth: 2,\n      outlineColor: \"#ffffff\",\n      outlineOpacity: 1\n    }\n  }\n},\n    Jr = [\"axis.ticks.text\", \"axis.legend.text\", \"legends.title.text\", \"legends.text\", \"legends.ticks.text\", \"legends.title.text\", \"labels.text\", \"dots.text\", \"markers.text\", \"annotations.text\"],\n    Qr = function Qr(e, r) {\n  var t = b({}, e, r);\n  return Jr.forEach(function (e) {\n    void 0 === y(t, e + \".fontFamily\") && v(t, e + \".fontFamily\", t.fontFamily), void 0 === y(t, e + \".fontSize\") && v(t, e + \".fontSize\", t.fontSize), void 0 === y(t, e + \".fill\") && v(t, e + \".fill\", t.textColor);\n  }), t;\n},\n    Zr = e(),\n    $r = function $r(e) {\n  var t = e.children,\n      i = e.animate,\n      n = e.stiffness,\n      o = e.damping,\n      a = e.config,\n      s = r(function () {\n    var e = x(a) ? q[a] : a;\n    return {\n      animate: i,\n      springConfig: {\n        stiffness: n,\n        damping: o\n      },\n      config: e\n    };\n  }, [i, n, o, a]);\n  return O(Zr.Provider, {\n    value: s,\n    children: t\n  });\n},\n    et = {\n  animate: c.bool,\n  motionStiffness: c.number,\n  motionDamping: c.number,\n  motionConfig: c.oneOfType([c.oneOf(Object.keys(q)), c.shape({\n    mass: c.number,\n    tension: c.number,\n    friction: c.number,\n    clamp: c.bool,\n    precision: c.number,\n    velocity: c.number,\n    duration: c.number,\n    easing: c.func\n  })])\n};\n\n$r.propTypes = {\n  children: c.node.isRequired,\n  animate: et.animate,\n  stiffness: et.motionStiffness,\n  damping: et.motionDamping,\n  config: et.motionConfig\n};\nvar rt = {\n  animate: !0,\n  stiffness: 90,\n  damping: 15,\n  config: \"default\"\n};\n$r.defaultProps = rt;\n\nvar tt = function tt() {\n  return t(Zr);\n},\n    it = function it(e) {\n  var t = tt(),\n      o = t.animate,\n      a = t.config,\n      s = function (e) {\n    var r = i();\n    return n(function () {\n      r.current = e;\n    }, [e]), r.current;\n  }(e),\n      l = r(function () {\n    return R(s, e);\n  }, [s, e]),\n      d = k({\n    from: {\n      value: 0\n    },\n    to: {\n      value: 1\n    },\n    reset: !0,\n    config: a,\n    immediate: !o\n  }).value;\n\n  return _(d, l);\n},\n    nt = {\n  nivo: [\"#d76445\", \"#f47560\", \"#e8c1a0\", \"#97e3d5\", \"#61cdbb\", \"#00b0a7\"],\n  BrBG: W(M),\n  PRGn: W(j),\n  PiYG: W(D),\n  PuOr: W(G),\n  RdBu: W(B),\n  RdGy: W(L),\n  RdYlBu: W(I),\n  RdYlGn: W(Y),\n  spectral: W(A),\n  blues: W(F),\n  greens: W(E),\n  greys: W(U),\n  oranges: W(X),\n  purples: W(K),\n  reds: W(H),\n  BuGn: W(N),\n  BuPu: W(V),\n  GnBu: W(J),\n  OrRd: W(Q),\n  PuBuGn: W(Z),\n  PuBu: W($),\n  PuRd: W(ee),\n  RdPu: W(re),\n  YlGnBu: W(te),\n  YlGn: W(ie),\n  YlOrBr: W(ne),\n  YlOrRd: W(oe)\n},\n    ot = Object.keys(nt),\n    at = function at(e) {\n  if (Qe(e)) {\n    if (!Qe(e.domain)) throw new Error(\"Provided colors should be a valid quantize scale providing a 'domain()' function\");\n    return e;\n  }\n\n  if (nt[e]) return z().range(nt[e]);\n  if (S(e)) return z().range(e);\n  throw new Error(\"Unable to guess quantize color scale from '\" + e + \"',\\nmust be a function or one of:\\n'\" + ot.join(\"', '\") + \"'\");\n},\n    st = {\n  nivo: [\"#e8c1a0\", \"#f47560\", \"#f1e15b\", \"#e8a838\", \"#61cdbb\", \"#97e3d5\"],\n  category10: ae,\n  accent: se,\n  dark2: le,\n  paired: de,\n  pastel1: ue,\n  pastel2: ce,\n  set1: fe,\n  set2: pe,\n  set3: he,\n  brown_blueGreen: W(M),\n  purpleRed_green: W(j),\n  pink_yellowGreen: W(D),\n  purple_orange: W(G),\n  red_blue: W(B),\n  red_grey: W(L),\n  red_yellow_blue: W(I),\n  red_yellow_green: W(Y),\n  spectral: W(A),\n  blues: W(F),\n  greens: W(E),\n  greys: W(U),\n  oranges: W(X),\n  purples: W(K),\n  reds: W(H),\n  blue_green: W(N),\n  blue_purple: W(V),\n  green_blue: W(J),\n  orange_red: W(Q),\n  purple_blue_green: W(Z),\n  purple_blue: W($),\n  purple_red: W(ee),\n  red_purple: W(re),\n  yellow_green_blue: W(te),\n  yellow_green: W(ie),\n  yellow_orange_brown: W(ne),\n  yellow_orange_red: W(oe)\n},\n    lt = [\"nivo\", \"category10\", \"accent\", \"dark2\", \"paired\", \"pastel1\", \"pastel2\", \"set1\", \"set2\", \"set3\", \"brown_blueGreen\", \"purpleRed_green\", \"pink_yellowGreen\", \"purple_orange\", \"red_blue\", \"red_grey\", \"red_yellow_blue\", \"red_yellow_green\", \"spectral\", \"blues\", \"greens\", \"greys\", \"oranges\", \"purples\", \"reds\", \"blue_green\", \"blue_purple\", \"green_blue\", \"orange_red\", \"purple_blue_green\", \"purple_blue\", \"purple_red\", \"red_purple\", \"yellow_green_blue\", \"yellow_green\", \"yellow_orange_brown\", \"yellow_orange_red\"],\n    dt = {\n  brown_blueGreen: ge,\n  purpleRed_green: me,\n  pink_yellowGreen: be,\n  purple_orange: ye,\n  red_blue: ve,\n  red_grey: Re,\n  red_yellow_blue: qe,\n  red_yellow_green: ke,\n  spectral: _e,\n  blues: we,\n  greens: xe,\n  greys: Oe,\n  oranges: Ce,\n  purples: We,\n  reds: Se,\n  viridis: ze,\n  inferno: Pe,\n  magma: Te,\n  plasma: Me,\n  warm: je,\n  cool: De,\n  cubehelixDefault: Ge,\n  blue_green: Be,\n  blue_purple: Le,\n  green_blue: Ie,\n  orange_red: Ye,\n  purple_blue_green: Ae,\n  purple_blue: Fe,\n  purple_red: Ee,\n  red_purple: Ue,\n  yellow_green_blue: Xe,\n  yellow_green: Ke,\n  yellow_orange_brown: He,\n  yellow_orange_red: Ne,\n  rainbow: Ve,\n  sinebow: Je\n},\n    ut = [\"brown_blueGreen\", \"purpleRed_green\", \"pink_yellowGreen\", \"purple_orange\", \"red_blue\", \"red_grey\", \"red_yellow_blue\", \"red_yellow_green\", \"spectral\", \"blues\", \"greens\", \"greys\", \"oranges\", \"purples\", \"reds\", \"viridis\", \"inferno\", \"magma\", \"plasma\", \"warm\", \"cool\", \"cubehelixDefault\", \"blue_green\", \"blue_purple\", \"green_blue\", \"orange_red\", \"purple_blue_green\", \"purple_blue\", \"purple_red\", \"red_purple\", \"yellow_green_blue\", \"yellow_green\", \"yellow_orange_brown\", \"yellow_orange_red\", \"rainbow\", \"sinebow\"],\n    ct = function ct() {\n  return P([\"#e8c1a0\", \"#f47560\", \"#f1e15b\", \"#e8a838\", \"#61cdbb\", \"#97e3d5\"]);\n},\n    ft = function ft(e, r) {\n  if (x(e)) {\n    var t = st[e];\n\n    if (void 0 !== t) {\n      var i = P(t);\n      return i.type = \"ordinal\", i;\n    }\n\n    if (void 0 !== r && 0 === e.indexOf(\"seq:\")) {\n      var n = dt[e.slice(4)];\n\n      if (void 0 !== n) {\n        var o = T(n).domain(r.domain());\n        return o.type = \"sequential\", o;\n      }\n    }\n  }\n\n  if (S(e)) {\n    var a = P(e);\n    return a.type = \"ordinal\", a;\n  }\n\n  return function () {\n    return e;\n  };\n},\n    pt = c.oneOfType([c.oneOf(ot), c.func, c.arrayOf(c.string)]),\n    ht = {\n  basis: $e,\n  basisClosed: er,\n  basisOpen: rr,\n  bundle: tr,\n  cardinal: ir,\n  cardinalClosed: nr,\n  cardinalOpen: or,\n  catmullRom: ar,\n  catmullRomClosed: sr,\n  catmullRomOpen: lr,\n  linear: dr,\n  linearClosed: ur,\n  monotoneX: cr,\n  monotoneY: fr,\n  natural: pr,\n  step: hr,\n  stepAfter: gr,\n  stepBefore: mr\n},\n    gt = Object.keys(ht),\n    mt = c.oneOf(gt),\n    bt = gt.filter(function (e) {\n  return e.endsWith(\"Closed\");\n}),\n    yt = Ze(gt, \"bundle\", \"basisClosed\", \"basisOpen\", \"cardinalClosed\", \"cardinalOpen\", \"catmullRomClosed\", \"catmullRomOpen\", \"linearClosed\"),\n    vt = Ze(gt, \"bundle\", \"basisClosed\", \"basisOpen\", \"cardinalClosed\", \"cardinalOpen\", \"catmullRomClosed\", \"catmullRomOpen\", \"linearClosed\"),\n    Rt = c.oneOf(vt),\n    qt = function qt(e) {\n  if (!ht[e]) throw new TypeError(\"'\" + e + \"', is not a valid curve interpolator identifier.\");\n  return ht[e];\n},\n    kt = {\n  defs: c.arrayOf(c.shape({\n    id: c.string.isRequired\n  })).isRequired,\n  fill: c.arrayOf(c.shape({\n    id: c.string.isRequired,\n    match: c.oneOfType([c.oneOf([\"*\"]), c.object, c.func]).isRequired\n  })).isRequired\n},\n    _t = {\n  ascending: br,\n  descending: yr,\n  insideOut: vr,\n  none: Rr,\n  reverse: qr\n},\n    wt = Object.keys(_t),\n    xt = c.oneOf(wt),\n    Ot = function Ot(e) {\n  return _t[e];\n},\n    Ct = {\n  expand: kr,\n  diverging: _r,\n  none: wr,\n  silhouette: xr,\n  wiggle: Or\n},\n    Wt = Object.keys(Ct),\n    St = c.oneOf(Wt),\n    zt = function zt(e) {\n  return Ct[e];\n},\n    Pt = c.shape({\n  top: c.number,\n  right: c.number,\n  bottom: c.number,\n  left: c.number\n}).isRequired,\n    Tt = [\"normal\", \"multiply\", \"screen\", \"overlay\", \"darken\", \"lighten\", \"color-dodge\", \"color-burn\", \"hard-light\", \"soft-light\", \"difference\", \"exclusion\", \"hue\", \"saturation\", \"color\", \"luminosity\"],\n    Mt = c.oneOf(Tt),\n    jt = function jt(e) {\n  return r(function () {\n    return qt(e);\n  }, [e]);\n},\n    Dt = !0,\n    Gt = 90,\n    Bt = 15,\n    Lt = ct,\n    It = P(he),\n    Yt = {\n  top: 0,\n  right: 0,\n  bottom: 0,\n  left: 0\n},\n    At = function At(e, t, i) {\n  return void 0 === i && (i = {}), r(function () {\n    var r = Gr({}, Yt, i);\n    return {\n      margin: r,\n      innerWidth: e - r.left - r.right,\n      innerHeight: t - r.top - r.bottom,\n      outerWidth: e,\n      outerHeight: t\n    };\n  }, [e, t, i.top, i.right, i.bottom, i.left]);\n},\n    Ft = function Ft() {\n  var e = i(null),\n      r = o({\n    left: 0,\n    top: 0,\n    width: 0,\n    height: 0\n  }),\n      t = r[0],\n      a = r[1],\n      s = o(function () {\n    return new ResizeObserver(function (e) {\n      var r = e[0];\n      return a(r.contentRect);\n    });\n  })[0];\n  return n(function () {\n    return e.current && s.observe(e.current), function () {\n      return s.disconnect();\n    };\n  }, []), [e, t];\n},\n    Et = function Et(e) {\n  return r(function () {\n    return Qr(Vr, e);\n  }, [e]);\n},\n    Ut = function Ut(e) {\n  return \"function\" == typeof e ? e : \"string\" == typeof e ? 0 === e.indexOf(\"time:\") ? Wr(e.slice(\"5\")) : Cr(e) : function (e) {\n    return \"\" + e;\n  };\n},\n    Xt = function Xt(e) {\n  return r(function () {\n    return Ut(e);\n  }, [e]);\n},\n    Kt = e(),\n    Ht = {},\n    Nt = function Nt(e) {\n  var r = e.theme,\n      t = void 0 === r ? Ht : r,\n      i = e.children,\n      n = Et(t);\n  return O(Kt.Provider, {\n    value: n,\n    children: i\n  });\n};\n\nNt.propTypes = {\n  children: c.node.isRequired,\n  theme: c.object\n};\n\nvar Vt = function Vt() {\n  return t(Kt);\n},\n    Jt = function Jt(e) {\n  var r = e.children,\n      t = e.condition,\n      i = e.wrapper;\n  return t ? a(i, {}, r) : r;\n};\n\nJt.propTypes = {\n  children: c.node.isRequired,\n  condition: c.bool.isRequired,\n  wrapper: c.element.isRequired\n};\n\nvar Qt = {\n  position: \"relative\"\n},\n    Zt = function Zt(e) {\n  var r = e.children,\n      t = e.theme,\n      n = e.renderWrapper,\n      o = void 0 === n || n,\n      a = e.isInteractive,\n      s = void 0 === a || a,\n      l = e.animate,\n      d = e.motionStiffness,\n      u = e.motionDamping,\n      c = e.motionConfig,\n      h = i(null);\n  return O(Nt, {\n    theme: t,\n    children: O($r, {\n      animate: l,\n      stiffness: d,\n      damping: u,\n      config: c,\n      children: O(f, {\n        container: h,\n        children: C(Jt, {\n          condition: o,\n          wrapper: O(\"div\", {\n            style: Qt,\n            ref: h\n          }),\n          children: [r, s && O(p, {})]\n        })\n      })\n    })\n  });\n};\n\nZt.propTypes = {\n  children: c.element.isRequired,\n  isInteractive: c.bool,\n  renderWrapper: c.bool,\n  theme: c.object,\n  animate: c.bool,\n  motionStiffness: c.number,\n  motionDamping: c.number,\n  motionConfig: c.string\n};\n\nvar $t = function $t() {},\n    ei = {\n  position: \"relative\"\n},\n    ri = function ri(e) {\n  var t = e.children,\n      n = e.theme,\n      o = e.isInteractive,\n      a = void 0 === o || o,\n      l = e.renderWrapper,\n      d = void 0 === l || l,\n      u = e.animate,\n      c = e.motionStiffness,\n      f = e.motionDamping,\n      b = e.motionConfig,\n      y = i(null),\n      v = h(y),\n      R = v.actions,\n      q = v.state,\n      k = s(function (e, r) {\n    return R.showTooltipFromEvent(e, r);\n  }, [R.showTooltipFromEvent]),\n      _ = r(function () {\n    return {\n      showTooltip: a ? k : $t,\n      hideTooltip: a ? R.hideTooltip : $t\n    };\n  }, [R.hideTooltip, a, k]);\n\n  return O(Nt, {\n    theme: n,\n    children: O($r, {\n      animate: u,\n      stiffness: c,\n      damping: f,\n      config: b,\n      children: O(g.Provider, {\n        value: R,\n        children: O(m.Provider, {\n          value: q,\n          children: C(Jt, {\n            condition: d,\n            wrapper: O(\"div\", {\n              style: ei,\n              ref: y\n            }),\n            children: [t(_), a && O(p, {})]\n          })\n        })\n      })\n    })\n  });\n};\n\nri.propTypes = {\n  children: c.func.isRequired,\n  isInteractive: c.bool,\n  renderWrapper: c.bool,\n  theme: c.object.isRequired,\n  animate: c.bool.isRequired,\n  motionStiffness: c.number,\n  motionDamping: c.number,\n  motionConfig: c.string\n};\n\nvar ti = function ti(e) {\n  var r = e.children,\n      t = Ft(),\n      i = t[0],\n      n = t[1],\n      o = n.width > 0 && n.height > 0;\n  return O(\"div\", {\n    ref: i,\n    style: {\n      width: \"100%\",\n      height: \"100%\"\n    },\n    children: o && r({\n      width: n.width,\n      height: n.height\n    })\n  });\n};\n\nti.propTypes = {\n  children: c.func.isRequired\n};\n\nvar ii = [\"id\", \"colors\"],\n    ni = function ni(e) {\n  var r = e.id,\n      t = e.colors,\n      i = Lr(e, ii);\n  return O(\"linearGradient\", Gr({\n    id: r,\n    x1: 0,\n    x2: 0,\n    y1: 0,\n    y2: 1\n  }, i, {\n    children: t.map(function (e) {\n      var r = e.offset,\n          t = e.color,\n          i = e.opacity;\n      return O(\"stop\", {\n        offset: r + \"%\",\n        stopColor: t,\n        stopOpacity: void 0 !== i ? i : 1\n      }, r);\n    })\n  }));\n};\n\nni.propTypes = {\n  id: c.string.isRequired,\n  colors: c.arrayOf(c.shape({\n    offset: c.number.isRequired,\n    color: c.string.isRequired,\n    opacity: c.number\n  })).isRequired,\n  gradientTransform: c.string\n};\n\nvar oi = function oi(e, r, t) {\n  return void 0 === t && (t = {}), Gr({\n    id: e,\n    type: \"linearGradient\",\n    colors: r\n  }, t);\n},\n    ai = {\n  linearGradient: ni\n},\n    si = l(function (e) {\n  var r = e.id,\n      t = e.background,\n      i = e.color,\n      n = e.size,\n      o = e.padding,\n      a = e.stagger,\n      s = n + o,\n      l = n / 2,\n      d = o / 2;\n  return !0 === a && (s = 2 * n + 2 * o), C(\"pattern\", {\n    id: r,\n    width: s,\n    height: s,\n    patternUnits: \"userSpaceOnUse\",\n    children: [O(\"rect\", {\n      width: s,\n      height: s,\n      fill: t\n    }), O(\"circle\", {\n      cx: d + l,\n      cy: d + l,\n      r: l,\n      fill: i\n    }), a && O(\"circle\", {\n      cx: 1.5 * o + n + l,\n      cy: 1.5 * o + n + l,\n      r: l,\n      fill: i\n    })]\n  });\n});\n\nsi.displayName = \"PatternDots\", si.propTypes = {\n  id: c.string.isRequired,\n  color: c.string.isRequired,\n  background: c.string.isRequired,\n  size: c.number.isRequired,\n  padding: c.number.isRequired,\n  stagger: c.bool.isRequired\n}, si.defaultProps = {\n  color: \"#000000\",\n  background: \"#ffffff\",\n  size: 4,\n  padding: 4,\n  stagger: !1\n};\n\nvar li = function li(e, r) {\n  return void 0 === r && (r = {}), Gr({\n    id: e,\n    type: \"patternDots\"\n  }, r);\n},\n    di = 2 * Math.PI,\n    ui = function ui(e) {\n  return e * Math.PI / 180;\n},\n    ci = function ci(e) {\n  return 180 * e / Math.PI;\n},\n    fi = function fi(e) {\n  return e.startAngle + (e.endAngle - e.startAngle) / 2;\n},\n    pi = function pi(e, r) {\n  return {\n    x: Math.cos(e) * r,\n    y: Math.sin(e) * r\n  };\n},\n    hi = function hi(e) {\n  var r = e % 360;\n  return r < 0 && (r += 360), r;\n},\n    gi = function gi(e) {\n  return e - di * Math.floor((e + Math.PI) / di);\n},\n    mi = function mi(e) {\n  return e < 0 ? 360 - -e % 360 : e % 360;\n},\n    bi = function bi(e, r, t) {\n  void 0 === t && (t = 360);\n  var i = r;\n  return Math.abs(r - e) > t && (i = e + (r > e ? t : -t)), [e, i];\n},\n    yi = {\n  svg: {\n    align: {\n      left: \"start\",\n      center: \"middle\",\n      right: \"end\",\n      start: \"start\",\n      middle: \"middle\",\n      end: \"end\"\n    },\n    baseline: {\n      top: \"text-before-edge\",\n      center: \"central\",\n      bottom: \"alphabetic\"\n    }\n  },\n  canvas: {\n    align: {\n      left: \"left\",\n      center: \"center\",\n      right: \"right\",\n      start: \"left\",\n      middle: \"center\",\n      end: \"right\"\n    },\n    baseline: {\n      top: \"top\",\n      center: \"middle\",\n      bottom: \"bottom\"\n    }\n  }\n},\n    vi = function vi(e, r, t, i) {\n  void 0 === i && (i = \"svg\");\n  var n = yi[i],\n      o = pi(r - Math.PI / 2, e),\n      a = o.x,\n      s = o.y,\n      l = ci(r),\n      d = n.align.center,\n      u = n.baseline.bottom;\n  return t > 0 ? (d = n.align.right, u = n.baseline.center) : t < 0 && (d = n.align.left, u = n.baseline.center), 0 !== t && l > 180 && (l -= 180, d = d === n.align.right ? n.align.left : n.align.right), {\n    x: a,\n    y: s,\n    rotate: l += t,\n    align: d,\n    baseline: u\n  };\n},\n    Ri = l(function (e) {\n  var r = e.id,\n      t = e.spacing,\n      i = e.rotation,\n      n = e.background,\n      o = e.color,\n      a = e.lineWidth,\n      s = Math.round(i) % 360,\n      l = Math.abs(t);\n  s > 180 ? s -= 360 : s > 90 ? s -= 180 : s < -180 ? s += 360 : s < -90 && (s += 180);\n  var d,\n      u = l,\n      c = l;\n  return 0 === s ? d = \"\\n                M 0 0 L \" + u + \" 0\\n                M 0 \" + c + \" L \" + u + \" \" + c + \"\\n            \" : 90 === s ? d = \"\\n                M 0 0 L 0 \" + c + \"\\n                M \" + u + \" 0 L \" + u + \" \" + c + \"\\n            \" : (u = Math.abs(l / Math.sin(ui(s))), c = l / Math.sin(ui(90 - s)), d = s > 0 ? \"\\n                    M 0 \" + -c + \" L \" + 2 * u + \" \" + c + \"\\n                    M \" + -u + \" \" + -c + \" L \" + u + \" \" + c + \"\\n                    M \" + -u + \" 0 L \" + u + \" \" + 2 * c + \"\\n                \" : \"\\n                    M \" + -u + \" \" + c + \" L \" + u + \" \" + -c + \"\\n                    M \" + -u + \" \" + 2 * c + \" L \" + 2 * u + \" \" + -c + \"\\n                    M 0 \" + 2 * c + \" L \" + 2 * u + \" 0\\n                \"), C(\"pattern\", {\n    id: r,\n    width: u,\n    height: c,\n    patternUnits: \"userSpaceOnUse\",\n    children: [O(\"rect\", {\n      width: u,\n      height: c,\n      fill: n,\n      stroke: \"rgba(255, 0, 0, 0.1)\",\n      strokeWidth: 0\n    }), O(\"path\", {\n      d: d,\n      strokeWidth: a,\n      stroke: o,\n      strokeLinecap: \"square\"\n    })]\n  });\n});\n\nRi.displayName = \"PatternLines\", Ri.propTypes = {\n  id: c.string.isRequired,\n  spacing: c.number.isRequired,\n  rotation: c.number.isRequired,\n  background: c.string.isRequired,\n  color: c.string.isRequired,\n  lineWidth: c.number.isRequired\n}, Ri.defaultProps = {\n  spacing: 5,\n  rotation: 0,\n  color: \"#000000\",\n  background: \"#ffffff\",\n  lineWidth: 2\n};\n\nvar qi = function qi(e, r) {\n  return void 0 === r && (r = {}), Gr({\n    id: e,\n    type: \"patternLines\"\n  }, r);\n},\n    ki = l(function (e) {\n  var r = e.id,\n      t = e.background,\n      i = e.color,\n      n = e.size,\n      o = e.padding,\n      a = e.stagger,\n      s = n + o,\n      l = o / 2;\n  return !0 === a && (s = 2 * n + 2 * o), C(\"pattern\", {\n    id: r,\n    width: s,\n    height: s,\n    patternUnits: \"userSpaceOnUse\",\n    children: [O(\"rect\", {\n      width: s,\n      height: s,\n      fill: t\n    }), O(\"rect\", {\n      x: l,\n      y: l,\n      width: n,\n      height: n,\n      fill: i\n    }), a && O(\"rect\", {\n      x: 1.5 * o + n,\n      y: 1.5 * o + n,\n      width: n,\n      height: n,\n      fill: i\n    })]\n  });\n});\n\nki.displayName = \"PatternSquares\", ki.propTypes = {\n  id: c.string.isRequired,\n  color: c.string.isRequired,\n  background: c.string.isRequired,\n  size: c.number.isRequired,\n  padding: c.number.isRequired,\n  stagger: c.bool.isRequired\n}, ki.defaultProps = {\n  color: \"#000000\",\n  background: \"#ffffff\",\n  size: 4,\n  padding: 4,\n  stagger: !1\n};\n\nvar _i = function _i(e, r) {\n  return void 0 === r && (r = {}), Gr({\n    id: e,\n    type: \"patternSquares\"\n  }, r);\n},\n    wi = {\n  patternDots: si,\n  patternLines: Ri,\n  patternSquares: ki\n},\n    xi = [\"type\"],\n    Oi = Gr({}, ai, wi),\n    Ci = function Ci(e) {\n  var r = e.defs;\n  return !r || r.length < 1 ? null : O(\"defs\", {\n    \"aria-hidden\": !0,\n    children: r.map(function (e) {\n      var r = e.type,\n          t = Lr(e, xi);\n      return Oi[r] ? d(Oi[r], Gr({\n        key: t.id\n      }, t)) : null;\n    })\n  });\n};\n\nCi.propTypes = {\n  defs: c.arrayOf(c.shape({\n    type: c.oneOf(Object.keys(Oi)).isRequired,\n    id: c.string.isRequired\n  }))\n};\n\nvar Wi = l(Ci),\n    Si = function Si(e) {\n  var r = e.width,\n      t = e.height,\n      i = e.margin,\n      n = e.defs,\n      o = e.children,\n      a = e.role,\n      s = e.ariaLabel,\n      l = e.ariaLabelledBy,\n      d = e.ariaDescribedBy,\n      u = e.isFocusable,\n      c = Vt();\n  return C(\"svg\", {\n    xmlns: \"http://www.w3.org/2000/svg\",\n    width: r,\n    height: t,\n    role: a,\n    \"aria-label\": s,\n    \"aria-labelledby\": l,\n    \"aria-describedby\": d,\n    focusable: u,\n    tabIndex: u ? 0 : void 0,\n    children: [O(Wi, {\n      defs: n\n    }), O(\"rect\", {\n      width: r,\n      height: t,\n      fill: c.background\n    }), O(\"g\", {\n      transform: \"translate(\" + i.left + \",\" + i.top + \")\",\n      children: o\n    })]\n  });\n};\n\nSi.propTypes = {\n  width: c.number.isRequired,\n  height: c.number.isRequired,\n  margin: c.shape({\n    top: c.number.isRequired,\n    left: c.number.isRequired\n  }).isRequired,\n  defs: c.array,\n  children: c.oneOfType([c.arrayOf(c.node), c.node]).isRequired,\n  role: c.string,\n  isFocusable: c.bool,\n  ariaLabel: c.string,\n  ariaLabelledBy: c.string,\n  ariaDescribedBy: c.string\n};\n\nvar zi = function zi(e) {\n  var r = e.size,\n      t = e.color,\n      i = e.borderWidth,\n      n = e.borderColor;\n  return O(\"circle\", {\n    r: r / 2,\n    fill: t,\n    stroke: n,\n    strokeWidth: i,\n    style: {\n      pointerEvents: \"none\"\n    }\n  });\n};\n\nzi.propTypes = {\n  size: c.number.isRequired,\n  color: c.string.isRequired,\n  borderWidth: c.number.isRequired,\n  borderColor: c.string.isRequired\n};\n\nvar Pi = l(zi),\n    Ti = function Ti(e) {\n  var r = e.x,\n      t = e.y,\n      i = e.symbol,\n      n = void 0 === i ? Pi : i,\n      o = e.size,\n      a = e.datum,\n      s = e.color,\n      l = e.borderWidth,\n      u = e.borderColor,\n      c = e.label,\n      f = e.labelTextAnchor,\n      p = void 0 === f ? \"middle\" : f,\n      h = e.labelYOffset,\n      g = void 0 === h ? -12 : h,\n      m = Vt(),\n      b = tt(),\n      y = b.animate,\n      v = b.config,\n      R = k({\n    transform: \"translate(\" + r + \", \" + t + \")\",\n    config: v,\n    immediate: !y\n  });\n  return C(w.g, {\n    transform: R.transform,\n    style: {\n      pointerEvents: \"none\"\n    },\n    children: [d(n, {\n      size: o,\n      color: s,\n      datum: a,\n      borderWidth: l,\n      borderColor: u\n    }), c && O(\"text\", {\n      textAnchor: p,\n      y: g,\n      style: m.dots.text,\n      children: c\n    })]\n  });\n};\n\nTi.propTypes = {\n  x: c.number.isRequired,\n  y: c.number.isRequired,\n  datum: c.object.isRequired,\n  size: c.number.isRequired,\n  color: c.string.isRequired,\n  borderWidth: c.number.isRequired,\n  borderColor: c.string.isRequired,\n  symbol: c.oneOfType([c.func, c.object]),\n  label: c.oneOfType([c.string, c.number]),\n  labelTextAnchor: c.oneOf([\"start\", \"middle\", \"end\"]),\n  labelYOffset: c.number.isRequired\n};\n\nvar Mi = l(Ti),\n    ji = function ji(e) {\n  var r = e.width,\n      t = e.height,\n      i = e.axis,\n      n = e.scale,\n      o = e.value,\n      a = e.lineStyle,\n      s = e.textStyle,\n      l = e.legend,\n      d = e.legendPosition,\n      u = e.legendOffsetX,\n      c = e.legendOffsetY,\n      f = e.legendOrientation,\n      p = Vt(),\n      h = 0,\n      g = 0,\n      m = 0,\n      b = 0;\n  \"y\" === i ? (m = n(o), g = r) : (h = n(o), b = t);\n  var y = null;\n\n  if (l) {\n    var v = function (e) {\n      var r = e.axis,\n          t = e.width,\n          i = e.height,\n          n = e.position,\n          o = e.offsetX,\n          a = e.offsetY,\n          s = e.orientation,\n          l = 0,\n          d = 0,\n          u = \"vertical\" === s ? -90 : 0,\n          c = \"start\";\n      if (\"x\" === r) switch (n) {\n        case \"top-left\":\n          l = -o, d = a, c = \"end\";\n          break;\n\n        case \"top\":\n          d = -a, c = \"horizontal\" === s ? \"middle\" : \"start\";\n          break;\n\n        case \"top-right\":\n          l = o, d = a, c = \"horizontal\" === s ? \"start\" : \"end\";\n          break;\n\n        case \"right\":\n          l = o, d = i / 2, c = \"horizontal\" === s ? \"start\" : \"middle\";\n          break;\n\n        case \"bottom-right\":\n          l = o, d = i - a, c = \"start\";\n          break;\n\n        case \"bottom\":\n          d = i + a, c = \"horizontal\" === s ? \"middle\" : \"end\";\n          break;\n\n        case \"bottom-left\":\n          d = i - a, l = -o, c = \"horizontal\" === s ? \"end\" : \"start\";\n          break;\n\n        case \"left\":\n          l = -o, d = i / 2, c = \"horizontal\" === s ? \"end\" : \"middle\";\n      } else switch (n) {\n        case \"top-left\":\n          l = o, d = -a, c = \"start\";\n          break;\n\n        case \"top\":\n          l = t / 2, d = -a, c = \"horizontal\" === s ? \"middle\" : \"start\";\n          break;\n\n        case \"top-right\":\n          l = t - o, d = -a, c = \"horizontal\" === s ? \"end\" : \"start\";\n          break;\n\n        case \"right\":\n          l = t + o, c = \"horizontal\" === s ? \"start\" : \"middle\";\n          break;\n\n        case \"bottom-right\":\n          l = t - o, d = a, c = \"end\";\n          break;\n\n        case \"bottom\":\n          l = t / 2, d = a, c = \"horizontal\" === s ? \"middle\" : \"end\";\n          break;\n\n        case \"bottom-left\":\n          l = o, d = a, c = \"horizontal\" === s ? \"start\" : \"end\";\n          break;\n\n        case \"left\":\n          l = -o, c = \"horizontal\" === s ? \"end\" : \"middle\";\n      }\n      return {\n        x: l,\n        y: d,\n        rotation: u,\n        textAnchor: c\n      };\n    }({\n      axis: i,\n      width: r,\n      height: t,\n      position: d,\n      offsetX: u,\n      offsetY: c,\n      orientation: f\n    });\n\n    y = O(\"text\", {\n      transform: \"translate(\" + v.x + \", \" + v.y + \") rotate(\" + v.rotation + \")\",\n      textAnchor: v.textAnchor,\n      dominantBaseline: \"central\",\n      style: s,\n      children: l\n    });\n  }\n\n  return C(\"g\", {\n    transform: \"translate(\" + h + \", \" + m + \")\",\n    children: [O(\"line\", {\n      x1: 0,\n      x2: g,\n      y1: 0,\n      y2: b,\n      stroke: p.markers.lineColor,\n      strokeWidth: p.markers.lineStrokeWidth,\n      style: a\n    }), y]\n  });\n};\n\nji.propTypes = {\n  width: c.number.isRequired,\n  height: c.number.isRequired,\n  axis: c.oneOf([\"x\", \"y\"]).isRequired,\n  scale: c.func.isRequired,\n  value: c.oneOfType([c.number, c.string, c.instanceOf(Date)]).isRequired,\n  lineStyle: c.object,\n  textStyle: c.object,\n  legend: c.string,\n  legendPosition: c.oneOf([\"top-left\", \"top\", \"top-right\", \"right\", \"bottom-right\", \"bottom\", \"bottom-left\", \"left\"]),\n  legendOffsetX: c.number.isRequired,\n  legendOffsetY: c.number.isRequired,\n  legendOrientation: c.oneOf([\"horizontal\", \"vertical\"]).isRequired\n}, ji.defaultProps = {\n  legendPosition: \"top-right\",\n  legendOffsetX: 14,\n  legendOffsetY: 14,\n  legendOrientation: \"horizontal\"\n};\n\nvar Di = l(ji),\n    Gi = function Gi(e) {\n  var r = e.markers,\n      t = e.width,\n      i = e.height,\n      n = e.xScale,\n      o = e.yScale;\n  return r && 0 !== r.length ? r.map(function (e, r) {\n    return O(Di, Gr({}, e, {\n      width: t,\n      height: i,\n      scale: \"y\" === e.axis ? o : n\n    }), r);\n  }) : null;\n};\n\nGi.propTypes = {\n  width: c.number.isRequired,\n  height: c.number.isRequired,\n  xScale: c.func.isRequired,\n  yScale: c.func.isRequired,\n  markers: c.arrayOf(c.shape({\n    axis: c.oneOf([\"x\", \"y\"]).isRequired,\n    value: c.oneOfType([c.number, c.string, c.instanceOf(Date)]).isRequired,\n    lineStyle: c.object,\n    textStyle: c.object\n  }))\n};\n\nvar Bi = l(Gi),\n    Li = function Li() {\n  return Sr(zr({\n    margin: Yt\n  }), Pr({\n    width: c.number.isRequired,\n    height: c.number.isRequired,\n    margin: Pt\n  }), Tr(function (e, r) {\n    return e.width !== r.width || e.height !== r.height || !Mr(e.margin, r.margin);\n  }, function (e) {\n    var r = Object.assign({}, Yt, e.margin);\n    return {\n      margin: r,\n      width: e.width - r.left - r.right,\n      height: e.height - r.top - r.bottom,\n      outerWidth: e.width,\n      outerHeight: e.height\n    };\n  }));\n},\n    Ii = function Ii() {\n  return Sr(Pr(et), zr({\n    animate: true,\n    motionDamping: 15,\n    motionStiffness: 90\n  }));\n},\n    Yi = function Yi(e) {\n  var r,\n      t = void 0 === e ? {} : e,\n      i = t.srcKey,\n      n = void 0 === i ? \"theme\" : i,\n      o = t.destKey,\n      a = void 0 === o ? \"theme\" : o;\n  return Sr(Pr(((r = {})[n] = c.object, r)), Tr([n], function (e) {\n    var r;\n    return (r = {})[a] = Qr(Vr, e[n]), r;\n  }));\n},\n    Ai = [\"theme\", \"renderWrapper\", \"animate\", \"motionStiffness\", \"motionDamping\", \"motionConfig\"],\n    Fi = function Fi(e) {\n  return function (r) {\n    var t, i;\n\n    function n() {\n      return r.apply(this, arguments) || this;\n    }\n\n    return i = r, (t = n).prototype = Object.create(i.prototype), t.prototype.constructor = t, Br(t, i), n.prototype.render = function () {\n      var r = this.props,\n          t = r.theme,\n          i = r.renderWrapper,\n          n = r.animate,\n          o = r.motionStiffness,\n          a = r.motionDamping,\n          s = r.motionConfig,\n          l = Lr(r, Ai);\n      return O(Zt, {\n        theme: t,\n        renderWrapper: i,\n        isInteractive: l.isInteractive,\n        animate: n,\n        motionStiffness: o,\n        motionDamping: a,\n        motionConfig: s,\n        children: O(e, Gr({}, l))\n      });\n    }, n;\n  }(u);\n},\n    Ei = function Ei(e, r) {\n  var t,\n      i = Qe(e) ? e : function (r) {\n    return y(r, e);\n  };\n  return r && (t = Qe(r) ? r : Cr(r)), t ? function (e) {\n    return t(i(e));\n  } : i;\n},\n    Ui = function Ui(e) {\n  return Qe(e) ? e : function (r) {\n    return y(r, e);\n  };\n},\n    Xi = function Xi(e) {\n  return r(function () {\n    return Ui(e);\n  }, [e]);\n},\n    Ki = [\"center\", \"top-left\", \"top\", \"top-right\", \"right\", \"bottom-right\", \"bottom\", \"bottom-left\", \"left\"],\n    Hi = function Hi(e, r, t) {\n  var i = r.width - e.width,\n      n = r.height - e.height,\n      o = 0,\n      a = 0;\n  return \"center\" === t && (o = i / 2, a = n / 2), \"top\" === t && (o = i / 2), \"top-right\" === t && (o = i), \"right\" === t && (o = i, a = n / 2), \"bottom-right\" === t && (o = i, a = n), \"bottom\" === t && (o = i / 2, a = n), \"bottom-left\" === t && (a = n), \"left\" === t && (a = n / 2), [o, a];\n},\n    Ni = function Ni(e, r, t, i) {\n  var n = t - e,\n      o = i - r;\n  return n *= n, o *= o, Math.sqrt(n + o);\n},\n    Vi = function Vi(e, r, t, i) {\n  var n = Math.atan2(i - r, t - e) - Math.PI / 2;\n  return n > 0 ? n : 2 * Math.PI + n;\n},\n    Ji = function Ji(e, r, t, i, n, o) {\n  return e <= n && n <= e + t && r <= o && o <= r + i;\n},\n    Qi = function Qi(e, r) {\n  var t = r.clientX,\n      i = r.clientY,\n      n = e.getBoundingClientRect();\n  return [t - n.left, i - n.top];\n},\n    Zi = Object.keys(ai),\n    $i = Object.keys(wi),\n    en = function en(e, r, t) {\n  if (\"*\" === e) return !0;\n  if (Qe(e)) return e(r);\n\n  if (jr(e)) {\n    var i = t ? y(r, t) : r;\n    return Mr(Dr(i, Object.keys(e)), e);\n  }\n\n  return !1;\n},\n    rn = function rn(e, r, t, i) {\n  var n = void 0 === i ? {} : i,\n      o = n.dataKey,\n      a = n.colorKey,\n      s = void 0 === a ? \"color\" : a,\n      l = n.targetKey,\n      d = void 0 === l ? \"fill\" : l,\n      u = [],\n      c = {};\n  return e.length && r.length && (u = [].concat(e), r.forEach(function (r) {\n    for (var i = function i(_i2) {\n      var n = t[_i2],\n          a = n.id,\n          l = n.match;\n\n      if (en(l, r, o)) {\n        var f = e.find(function (e) {\n          return e.id === a;\n        });\n        if (f) if ($i.includes(f.type)) {\n          if (\"inherit\" === f.background || \"inherit\" === f.color) {\n            var p = y(r, s),\n                h = f.background,\n                g = f.color,\n                m = a;\n            \"inherit\" === f.background && (m = m + \".bg.\" + p, h = p), \"inherit\" === f.color && (m = m + \".fg.\" + p, g = p), v(r, d, \"url(#\" + m + \")\"), c[m] || (u.push(Gr({}, f, {\n              id: m,\n              background: h,\n              color: g\n            })), c[m] = 1);\n          } else v(r, d, \"url(#\" + a + \")\");\n        } else if (Zi.includes(f.type)) {\n          if (f.colors.map(function (e) {\n            return e.color;\n          }).includes(\"inherit\")) {\n            var b = y(r, s),\n                R = a,\n                q = Gr({}, f, {\n              colors: f.colors.map(function (e, r) {\n                return \"inherit\" !== e.color ? e : (R = R + \".\" + r + \".\" + b, Gr({}, e, {\n                  color: \"inherit\" === e.color ? b : e.color\n                }));\n              })\n            });\n            q.id = R, v(r, d, \"url(#\" + R + \")\"), c[R] || (u.push(q), c[R] = 1);\n          } else v(r, d, \"url(#\" + a + \")\");\n        }\n        return \"break\";\n      }\n    }, n = 0; n < t.length; n++) {\n      if (\"break\" === i(n)) break;\n    }\n  })), u;\n};\n\nexport { Bi as CartesianMarkers, Di as CartesianMarkersItem, Zt as Container, Wi as Defs, Mi as DotsItem, ri as LegacyContainer, ni as LinearGradient, $r as MotionConfigProvider, si as PatternDots, Ri as PatternLines, ki as PatternSquares, ti as ResponsiveWrapper, Si as SvgWrapper, di as TWO_PI, Nt as ThemeProvider, hi as absoluteAngleDegrees, gi as absoluteAngleRadians, Hi as alignBox, Hr as annotationsPropType, yt as areaCurvePropKeys, Yr as axisThemePropType, rn as bindDefs, Mt as blendModePropType, Tt as blendModes, Ki as boxAlignments, bi as clampArc, bt as closedCurvePropKeys, ut as colorInterpolatorIds, dt as colorInterpolators, lt as colorSchemeIds, Kr as crosshairPropType, qt as curveFromProp, gt as curvePropKeys, ht as curvePropMapping, mt as curvePropType, Dt as defaultAnimate, Lt as defaultCategoricalColors, It as defaultColorRange, Yt as defaultMargin, Bt as defaultMotionDamping, Gt as defaultMotionStiffness, Vr as defaultTheme, kt as defsPropTypes, ui as degreesToRadians, Ur as dotsThemePropType, Qr as extendDefaultTheme, Vi as getAngle, ft as getColorScale, Ni as getDistance, Ei as getLabelGenerator, vi as getPolarLabelProps, Ui as getPropertyAccessor, Qi as getRelativeCursor, Ut as getValueFormatter, ai as gradientTypes, Ar as gridThemePropType, at as guessQuantizeColorScale, Ji as isCursorInRect, en as isMatchingDef, Er as labelsThemePropType, Fr as legendsThemePropType, vt as lineCurvePropKeys, Rt as lineCurvePropType, oi as linearGradientDef, Pt as marginPropType, Xr as markersThemePropType, fi as midAngle, Zr as motionConfigContext, rt as motionDefaultProps, et as motionPropTypes, ct as nivoCategoricalColors, $t as noop, mi as normalizeAngle, li as patternDotsDef, qi as patternLinesDef, _i as patternSquaresDef, wi as patternTypes, pi as positionFromAngle, pt as quantizeColorScalePropType, nt as quantizeColorScales, ot as quantizeColorScalesKeys, ci as radiansToDegrees, zt as stackOffsetFromProp, Wt as stackOffsetPropKeys, Ct as stackOffsetPropMapping, St as stackOffsetPropType, Ot as stackOrderFromProp, wt as stackOrderPropKeys, _t as stackOrderPropMapping, xt as stackOrderPropType, yi as textPropsByEngine, Kt as themeContext, Nr as themePropType, it as useAnimatedPath, jt as useCurveInterpolation, At as useDimensions, Ft as useMeasure, tt as useMotionConfig, Et as usePartialTheme, Xi as usePropertyAccessor, Vt as useTheme, Xt as useValueFormatter, Fi as withContainer, Li as withDimensions, Ii as withMotion, Yi as withTheme };","map":null,"metadata":{},"sourceType":"module"}