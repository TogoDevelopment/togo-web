{"ast":null,"code":"import _classCallCheck from \"/home/system/togo-web-test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/system/togo-web-test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\n/**\n * This is a modified version of `PanSession` from `framer-motion`.\n *\n * Credit goes to `framer-motion` of this useful utilities.\n * License can be found here: https://github.com/framer/motion\n */\nimport sync, { cancelSync, getFrameData } from \"framesync\";\nimport { isMouseEvent, extractEventInfo, addPointerEvent, isMultiTouchEvent } from \"./pointer-event\";\nimport { pipe, distance, noop } from \"./function\";\n/**\n * The event information passed to pan event handlers like `onPan`, `onPanStart`.\n *\n * It contains information about the current state of the tap gesture such as its\n * `point`, `delta`, and `offset`\n */\n\n/**\n * @internal\n *\n * A Pan Session is recognized when the pointer is down\n * and moved in the allowed direction.\n */\nexport var PanSession = /*#__PURE__*/function () {\n  /**\n   * We use this to keep track of the `x` and `y` pan session history\n   * as the pan event happens. It helps to calculate the `offset` and `delta`\n   */\n  // The pointer event that started the pan session\n  // The current pointer event for the pan session\n  // The current pointer event info for the pan session\n\n  /**\n   * Minimal pan distance required before recognizing the pan.\n   * @default \"3px\"\n   */\n  function PanSession(_event, handlers, threshold) {\n    var _this = this;\n    _classCallCheck(this, PanSession);\n    _defineProperty(this, \"history\", []);\n    _defineProperty(this, \"startEvent\", null);\n    _defineProperty(this, \"lastEvent\", null);\n    _defineProperty(this, \"lastEventInfo\", null);\n    _defineProperty(this, \"handlers\", {});\n    _defineProperty(this, \"removeListeners\", noop);\n    _defineProperty(this, \"threshold\", 3);\n    _defineProperty(this, \"updatePoint\", function () {\n      if (!(_this.lastEvent && _this.lastEventInfo)) return;\n      var info = getPanInfo(_this.lastEventInfo, _this.history);\n      var isPanStarted = _this.startEvent !== null;\n      var isDistancePastThreshold = distance(info.offset, {\n        x: 0,\n        y: 0\n      }) >= _this.threshold;\n      if (!isPanStarted && !isDistancePastThreshold) return;\n      var _getFrameData = getFrameData(),\n        timestamp = _getFrameData.timestamp;\n      _this.history.push(_extends({}, info.point, {\n        timestamp: timestamp\n      }));\n      var _this$handlers = _this.handlers,\n        onStart = _this$handlers.onStart,\n        onMove = _this$handlers.onMove;\n      if (!isPanStarted) {\n        onStart == null ? void 0 : onStart(_this.lastEvent, info);\n        _this.startEvent = _this.lastEvent;\n      }\n      onMove == null ? void 0 : onMove(_this.lastEvent, info);\n    });\n    _defineProperty(this, \"onPointerMove\", function (event, info) {\n      _this.lastEvent = event;\n      _this.lastEventInfo = info; // Because Safari doesn't trigger mouseup events when it's above a `<select>`\n\n      if (isMouseEvent(event) && event.buttons === 0) {\n        _this.onPointerUp(event, info);\n        return;\n      } // Throttle mouse move event to once per frame\n\n      sync.update(_this.updatePoint, true);\n    });\n    _defineProperty(this, \"onPointerUp\", function (event, info) {\n      // notify pan session ended\n      var panInfo = getPanInfo(info, _this.history);\n      var _this$handlers2 = _this.handlers,\n        onEnd = _this$handlers2.onEnd,\n        onSessionEnd = _this$handlers2.onSessionEnd;\n      onSessionEnd == null ? void 0 : onSessionEnd(event, panInfo);\n      _this.end(); // if panning never started, no need to call `onEnd`\n      // panning requires a pointermove of at least 3px\n\n      if (!onEnd || !_this.startEvent) return;\n      onEnd == null ? void 0 : onEnd(event, panInfo);\n    });\n\n    // If we have more than one touch, don't start detecting this gesture\n    if (isMultiTouchEvent(_event)) return;\n    this.handlers = handlers;\n    if (threshold) {\n      this.threshold = threshold;\n    } // stop default browser behavior\n\n    _event.stopPropagation();\n    _event.preventDefault(); // get and save the `pointerdown` event info in history\n    // we'll use it to compute the `offset`\n\n    var _info = extractEventInfo(_event);\n    var _getFrameData2 = getFrameData(),\n      _timestamp = _getFrameData2.timestamp;\n    this.history = [_extends({}, _info.point, {\n      timestamp: _timestamp\n    })]; // notify pan session start\n\n    var onSessionStart = handlers.onSessionStart;\n    onSessionStart == null ? void 0 : onSessionStart(_event, getPanInfo(_info, this.history)); // attach event listeners and return a single function to remove them all\n\n    this.removeListeners = pipe(addPointerEvent(window, \"pointermove\", this.onPointerMove), addPointerEvent(window, \"pointerup\", this.onPointerUp), addPointerEvent(window, \"pointercancel\", this.onPointerUp));\n  }\n  _createClass(PanSession, [{\n    key: \"updateHandlers\",\n    value: function updateHandlers(handlers) {\n      this.handlers = handlers;\n    }\n  }, {\n    key: \"end\",\n    value: function end() {\n      var _this$removeListeners;\n      (_this$removeListeners = this.removeListeners) == null ? void 0 : _this$removeListeners.call(this);\n      cancelSync.update(this.updatePoint);\n    }\n  }]);\n  return PanSession;\n}();\nfunction subtractPoint(a, b) {\n  return {\n    x: a.x - b.x,\n    y: a.y - b.y\n  };\n}\nfunction startPanPoint(history) {\n  return history[0];\n}\nfunction lastPanPoint(history) {\n  return history[history.length - 1];\n}\nfunction getPanInfo(info, history) {\n  return {\n    point: info.point,\n    delta: subtractPoint(info.point, lastPanPoint(history)),\n    offset: subtractPoint(info.point, startPanPoint(history)),\n    velocity: getVelocity(history, 0.1)\n  };\n}\nfunction lastDevicePoint(history) {\n  return history[history.length - 1];\n}\nvar toMilliseconds = function toMilliseconds(seconds) {\n  return seconds * 1000;\n};\nfunction getVelocity(history, timeDelta) {\n  if (history.length < 2) {\n    return {\n      x: 0,\n      y: 0\n    };\n  }\n  var i = history.length - 1;\n  var timestampedPoint = null;\n  var lastPoint = lastDevicePoint(history);\n  while (i >= 0) {\n    timestampedPoint = history[i];\n    if (lastPoint.timestamp - timestampedPoint.timestamp > toMilliseconds(timeDelta)) {\n      break;\n    }\n    i--;\n  }\n  if (!timestampedPoint) {\n    return {\n      x: 0,\n      y: 0\n    };\n  }\n  var time = (lastPoint.timestamp - timestampedPoint.timestamp) / 1000;\n  if (time === 0) {\n    return {\n      x: 0,\n      y: 0\n    };\n  }\n  var currentVelocity = {\n    x: (lastPoint.x - timestampedPoint.x) / time,\n    y: (lastPoint.y - timestampedPoint.y) / time\n  };\n  if (currentVelocity.x === Infinity) {\n    currentVelocity.x = 0;\n  }\n  if (currentVelocity.y === Infinity) {\n    currentVelocity.y = 0;\n  }\n  return currentVelocity;\n}","map":{"version":3,"names":["sync","cancelSync","getFrameData","isMouseEvent","extractEventInfo","addPointerEvent","isMultiTouchEvent","pipe","distance","noop","PanSession","_event","handlers","threshold","_this","_classCallCheck","_defineProperty","lastEvent","lastEventInfo","info","getPanInfo","history","isPanStarted","startEvent","isDistancePastThreshold","offset","x","y","_getFrameData","timestamp","push","_extends","point","_this$handlers","onStart","onMove","event","buttons","onPointerUp","update","updatePoint","panInfo","_this$handlers2","onEnd","onSessionEnd","end","stopPropagation","preventDefault","_info","_getFrameData2","_timestamp","onSessionStart","removeListeners","window","onPointerMove","_createClass","key","value","updateHandlers","_this$removeListeners","call","subtractPoint","a","b","startPanPoint","lastPanPoint","length","delta","velocity","getVelocity","lastDevicePoint","toMilliseconds","seconds","timeDelta","i","timestampedPoint","lastPoint","time","currentVelocity","Infinity"],"sources":["../../src/pan-event.ts"],"sourcesContent":["/**\n * This is a modified version of `PanSession` from `framer-motion`.\n *\n * Credit goes to `framer-motion` of this useful utilities.\n * License can be found here: https://github.com/framer/motion\n */\n\nimport sync, { cancelSync, getFrameData } from \"framesync\"\nimport {\n  isMouseEvent,\n  extractEventInfo,\n  addPointerEvent,\n  AnyPointerEvent,\n  Point,\n  PointerEventInfo,\n  isMultiTouchEvent,\n} from \"./pointer-event\"\nimport { pipe, distance, noop } from \"./function\"\n\n/**\n * The event information passed to pan event handlers like `onPan`, `onPanStart`.\n *\n * It contains information about the current state of the tap gesture such as its\n * `point`, `delta`, and `offset`\n */\nexport interface PanEventInfo {\n  /**\n   * Contains `x` and `y` values for the current pan position relative\n   * to the device or page.\n   */\n  point: Point\n  /**\n   * Contains `x` and `y` values for the distance moved since\n   * the last pan event.\n   */\n  delta: Point\n  /**\n   * Contains `x` and `y` values for the distance moved from\n   * the first pan event.\n   */\n  offset: Point\n  /**\n   * Contains `x` and `y` values for the current velocity of the pointer.\n   */\n  velocity: Point\n}\n\nexport type PanEventHandler = (\n  event: AnyPointerEvent,\n  info: PanEventInfo,\n) => void\n\ninterface TimestampedPoint extends Point {\n  timestamp: number\n}\n\nexport interface PanSessionHandlers {\n  /**\n   * Callback fired when the pan session is created.\n   * This is typically called once `pointerdown` event is fired.\n   */\n  onSessionStart: PanEventHandler\n  /**\n   * Callback fired when the pan session is detached.\n   * This is typically called once `pointerup` event is fired.\n   */\n  onSessionEnd: PanEventHandler\n  /**\n   * Callback fired when the pan session has started.\n   * The pan session when the pan offset is greater than\n   * the threshold (allowable move distance to detect pan)\n   */\n  onStart: PanEventHandler\n  /**\n   * Callback fired while panning\n   */\n  onMove: PanEventHandler\n  /**\n   * Callback fired when the current pan session has end.\n   * This is typically called once `pointerup` event is fired.\n   */\n  onEnd: PanEventHandler\n}\n\ntype PanSessionHistory = TimestampedPoint[]\n\n/**\n * @internal\n *\n * A Pan Session is recognized when the pointer is down\n * and moved in the allowed direction.\n */\nexport class PanSession {\n  /**\n   * We use this to keep track of the `x` and `y` pan session history\n   * as the pan event happens. It helps to calculate the `offset` and `delta`\n   */\n  private history: PanSessionHistory = []\n\n  // The pointer event that started the pan session\n  private startEvent: AnyPointerEvent | null = null\n\n  // The current pointer event for the pan session\n  private lastEvent: AnyPointerEvent | null = null\n\n  // The current pointer event info for the pan session\n  private lastEventInfo: PointerEventInfo | null = null\n\n  private handlers: Partial<PanSessionHandlers> = {}\n\n  private removeListeners: Function = noop\n\n  /**\n   * Minimal pan distance required before recognizing the pan.\n   * @default \"3px\"\n   */\n  private threshold = 3\n\n  constructor(\n    event: AnyPointerEvent,\n    handlers: Partial<PanSessionHandlers>,\n    threshold?: number,\n  ) {\n    // If we have more than one touch, don't start detecting this gesture\n    if (isMultiTouchEvent(event)) return\n\n    this.handlers = handlers\n\n    if (threshold) {\n      this.threshold = threshold\n    }\n\n    // stop default browser behavior\n    event.stopPropagation()\n    event.preventDefault()\n\n    // get and save the `pointerdown` event info in history\n    // we'll use it to compute the `offset`\n    const info = extractEventInfo(event)\n    const { timestamp } = getFrameData()\n    this.history = [{ ...info.point, timestamp }]\n\n    // notify pan session start\n    const { onSessionStart } = handlers\n    onSessionStart?.(event, getPanInfo(info, this.history))\n\n    // attach event listeners and return a single function to remove them all\n    this.removeListeners = pipe(\n      addPointerEvent(window, \"pointermove\", this.onPointerMove),\n      addPointerEvent(window, \"pointerup\", this.onPointerUp),\n      addPointerEvent(window, \"pointercancel\", this.onPointerUp),\n    )\n  }\n\n  private updatePoint = () => {\n    if (!(this.lastEvent && this.lastEventInfo)) return\n\n    const info = getPanInfo(this.lastEventInfo, this.history)\n\n    const isPanStarted = this.startEvent !== null\n\n    const isDistancePastThreshold =\n      distance(info.offset, { x: 0, y: 0 }) >= this.threshold\n\n    if (!isPanStarted && !isDistancePastThreshold) return\n\n    const { timestamp } = getFrameData()\n    this.history.push({ ...info.point, timestamp })\n\n    const { onStart, onMove } = this.handlers\n\n    if (!isPanStarted) {\n      onStart?.(this.lastEvent, info)\n      this.startEvent = this.lastEvent\n    }\n\n    onMove?.(this.lastEvent, info)\n  }\n\n  private onPointerMove = (event: AnyPointerEvent, info: PointerEventInfo) => {\n    this.lastEvent = event\n    this.lastEventInfo = info\n\n    // Because Safari doesn't trigger mouseup events when it's above a `<select>`\n    if (isMouseEvent(event) && event.buttons === 0) {\n      this.onPointerUp(event, info)\n      return\n    }\n\n    // Throttle mouse move event to once per frame\n    sync.update(this.updatePoint, true)\n  }\n\n  private onPointerUp = (event: AnyPointerEvent, info: PointerEventInfo) => {\n    // notify pan session ended\n    const panInfo = getPanInfo(info, this.history)\n    const { onEnd, onSessionEnd } = this.handlers\n\n    onSessionEnd?.(event, panInfo)\n    this.end()\n\n    // if panning never started, no need to call `onEnd`\n    // panning requires a pointermove of at least 3px\n    if (!onEnd || !this.startEvent) return\n\n    onEnd?.(event, panInfo)\n  }\n\n  updateHandlers(handlers: Partial<PanSessionHandlers>) {\n    this.handlers = handlers\n  }\n\n  end() {\n    this.removeListeners?.()\n    cancelSync.update(this.updatePoint)\n  }\n}\n\nfunction subtractPoint(a: Point, b: Point) {\n  return { x: a.x - b.x, y: a.y - b.y }\n}\n\nfunction startPanPoint(history: PanSessionHistory) {\n  return history[0]\n}\n\nfunction lastPanPoint(history: PanSessionHistory) {\n  return history[history.length - 1]\n}\n\nfunction getPanInfo(info: PointerEventInfo, history: PanSessionHistory) {\n  return {\n    point: info.point,\n    delta: subtractPoint(info.point, lastPanPoint(history)),\n    offset: subtractPoint(info.point, startPanPoint(history)),\n    velocity: getVelocity(history, 0.1),\n  }\n}\n\nfunction lastDevicePoint(history: TimestampedPoint[]): TimestampedPoint {\n  return history[history.length - 1]\n}\n\nconst toMilliseconds = (seconds: number) => seconds * 1000\n\nfunction getVelocity(history: TimestampedPoint[], timeDelta: number): Point {\n  if (history.length < 2) {\n    return { x: 0, y: 0 }\n  }\n\n  let i = history.length - 1\n  let timestampedPoint: TimestampedPoint | null = null\n  const lastPoint = lastDevicePoint(history)\n  while (i >= 0) {\n    timestampedPoint = history[i]\n    if (\n      lastPoint.timestamp - timestampedPoint.timestamp >\n      toMilliseconds(timeDelta)\n    ) {\n      break\n    }\n    i--\n  }\n\n  if (!timestampedPoint) {\n    return { x: 0, y: 0 }\n  }\n\n  const time = (lastPoint.timestamp - timestampedPoint.timestamp) / 1000\n  if (time === 0) {\n    return { x: 0, y: 0 }\n  }\n\n  const currentVelocity = {\n    x: (lastPoint.x - timestampedPoint.x) / time,\n    y: (lastPoint.y - timestampedPoint.y) / time,\n  }\n\n  if (currentVelocity.x === Infinity) {\n    currentVelocity.x = 0\n  }\n  if (currentVelocity.y === Infinity) {\n    currentVelocity.y = 0\n  }\n\n  return currentVelocity\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}