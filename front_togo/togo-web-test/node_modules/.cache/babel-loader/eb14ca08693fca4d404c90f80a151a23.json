{"ast":null,"code":"import _regeneratorRuntime from \"/home/system/togo-web-test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/home/system/togo-web-test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"/home/system/togo-web-test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/system/togo-web-test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\n(function () {\n  var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;\n  enterModule && enterModule(module);\n})();\nvar __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {\n  return a;\n};\n\n/**\n * A utility for communications between an iframe and its parent, used by the Superset embedded SDK.\n * This builds useful patterns on top of the basic functionality offered by MessageChannel.\n *\n * Both windows instantiate a Switchboard, passing in their MessagePorts.\n * Calling methods on the switchboard causes messages to be sent through the channel.\n */\nexport var Switchboard = /*#__PURE__*/function () {\n  // used to make unique ids\n\n  function Switchboard(_ref) {\n    var _this = this;\n    var port = _ref.port,\n      _ref$name = _ref.name,\n      name = _ref$name === void 0 ? 'switchboard' : _ref$name,\n      _ref$debug = _ref.debug,\n      debug = _ref$debug === void 0 ? false : _ref$debug;\n    _classCallCheck(this, Switchboard);\n    this.port = void 0;\n    this.name = void 0;\n    this.methods = {};\n    this.incrementor = 1;\n    this.debugMode = void 0;\n    this.port = port;\n    this.name = name;\n    this.debugMode = debug;\n    port.addEventListener('message', /*#__PURE__*/function () {\n      var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(event) {\n        var message, method, args, executor;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _this.log('message received', event);\n                message = event.data;\n                if (!isGet(message)) {\n                  _context.next = 10;\n                  break;\n                }\n                _context.t0 = _this.port;\n                _context.next = 6;\n                return _this.getMethodResult(message);\n              case 6:\n                _context.t1 = _context.sent;\n                _context.t0.postMessage.call(_context.t0, _context.t1);\n                _context.next = 11;\n                break;\n              case 10:\n                if (isEmit(message)) {\n                  method = message.method, args = message.args; // Find the method and call it, but no result necessary.\n                  // Should this multicast to a set of listeners?\n                  // Maybe, but that requires writing a bunch more code\n                  // and I haven't found a need for it yet.\n                  executor = _this.methods[method];\n                  if (executor) {\n                    executor(args);\n                  }\n                }\n              case 11:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n      return function (_x) {\n        return _ref2.apply(this, arguments);\n      };\n    }());\n  }\n  _createClass(Switchboard, [{\n    key: \"getMethodResult\",\n    value: function () {\n      var _getMethodResult = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(_ref3) {\n        var messageId, method, args, executor, result;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                messageId = _ref3.messageId, method = _ref3.method, args = _ref3.args;\n                executor = this.methods[method];\n                if (!(executor == null)) {\n                  _context2.next = 4;\n                  break;\n                }\n                return _context2.abrupt(\"return\", {\n                  switchboardAction: Actions.ERROR,\n                  messageId: messageId,\n                  error: \"[\".concat(this.name, \"] Method \\\"\").concat(method, \"\\\" is not defined\")\n                });\n              case 4:\n                _context2.prev = 4;\n                _context2.next = 7;\n                return executor(args);\n              case 7:\n                result = _context2.sent;\n                return _context2.abrupt(\"return\", {\n                  switchboardAction: Actions.REPLY,\n                  messageId: messageId,\n                  result: result\n                });\n              case 11:\n                _context2.prev = 11;\n                _context2.t0 = _context2[\"catch\"](4);\n                this.logError(_context2.t0);\n                return _context2.abrupt(\"return\", {\n                  switchboardAction: Actions.ERROR,\n                  messageId: messageId,\n                  error: \"[\".concat(this.name, \"] Method \\\"\").concat(method, \"\\\" threw an error\")\n                });\n              case 15:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this, [[4, 11]]);\n      }));\n      function getMethodResult(_x2) {\n        return _getMethodResult.apply(this, arguments);\n      }\n      return getMethodResult;\n    }()\n    /**\n     * Defines a method that can be \"called\" from the other side by sending an event.\n     */\n  }, {\n    key: \"defineMethod\",\n    value: function defineMethod(methodName, executor) {\n      this.methods[methodName] = executor;\n    }\n\n    /**\n     * Calls a method registered on the other side, and returns the result.\n     *\n     * How this is accomplished:\n     * This switchboard sends a \"get\" message over the channel describing which method to call with which arguments.\n     * The other side's switchboard finds a method with that name, and calls it with the arguments.\n     * It then packages up the returned value into a \"reply\" message, sending it back to us across the channel.\n     * This switchboard has attached a listener on the channel, which will resolve with the result when a reply is detected.\n     *\n     * Instead of an arguments list, arguments are supplied as a map.\n     *\n     * @param method the name of the method to call\n     * @param args arguments that will be supplied. Must be serializable, no functions or other nonense.\n     * @returns whatever is returned from the method\n     */\n  }, {\n    key: \"get\",\n    value: function get(method) {\n      var _this2 = this;\n      var args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n      return new Promise(function (resolve, reject) {\n        // In order to \"call a method\" on the other side of the port,\n        // we will send a message with a unique id\n        var messageId = _this2.getNewMessageId();\n        // attach a new listener to our port, and remove it when we get a response\n        var listener = function listener(event) {\n          var message = event.data;\n          if (message.messageId !== messageId) return;\n          _this2.port.removeEventListener('message', listener);\n          if (isReply(message)) {\n            resolve(message.result);\n          } else {\n            var errStr = isError(message) ? message.error : 'Unexpected response message';\n            reject(new Error(errStr));\n          }\n        };\n        _this2.port.addEventListener('message', listener);\n        _this2.port.start();\n        var message = {\n          switchboardAction: Actions.GET,\n          method: method,\n          messageId: messageId,\n          args: args\n        };\n        _this2.port.postMessage(message);\n      });\n    }\n\n    /**\n     * Emit calls a method on the other side just like get does.\n     * But emit doesn't wait for a response, it just sends and forgets.\n     *\n     * @param method\n     * @param args\n     */\n  }, {\n    key: \"emit\",\n    value: function emit(method) {\n      var args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n      var message = {\n        switchboardAction: Actions.EMIT,\n        method: method,\n        args: args\n      };\n      this.port.postMessage(message);\n    }\n  }, {\n    key: \"start\",\n    value: function start() {\n      this.port.start();\n    }\n  }, {\n    key: \"log\",\n    value: function log() {\n      if (this.debugMode) {\n        var _console;\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n        (_console = console).debug.apply(_console, [\"[\".concat(this.name, \"]\")].concat(args));\n      }\n    }\n  }, {\n    key: \"logError\",\n    value: function logError() {\n      var _console2;\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n      (_console2 = console).error.apply(_console2, [\"[\".concat(this.name, \"]\")].concat(args));\n    }\n  }, {\n    key: \"getNewMessageId\",\n    value: function getNewMessageId() {\n      // eslint-disable-next-line no-plusplus\n      return \"m_\".concat(this.name, \"_\").concat(this.incrementor++);\n    } // @ts-ignore\n  }, {\n    key: \"__reactstandin__regenerateByEval\",\n    value: function __reactstandin__regenerateByEval(key, code) {\n      // @ts-ignore\n      this[key] = eval(code);\n    }\n  }]);\n  return Switchboard;\n}();\n\n// Each message we send on the channel specifies an action we want the other side to cooperate with.\nvar Actions;\n\n// helper types/functions for making sure wires don't get crossed\n(function (Actions) {\n  Actions[\"GET\"] = \"get\";\n  Actions[\"REPLY\"] = \"reply\";\n  Actions[\"EMIT\"] = \"emit\";\n  Actions[\"ERROR\"] = \"error\";\n})(Actions || (Actions = {}));\nfunction isGet(message) {\n  return message.switchboardAction === Actions.GET;\n}\nfunction isReply(message) {\n  return message.switchboardAction === Actions.REPLY;\n}\nfunction isEmit(message) {\n  return message.switchboardAction === Actions.EMIT;\n}\nfunction isError(message) {\n  return message.switchboardAction === Actions.ERROR;\n}\n;\n(function () {\n  var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;\n  if (!reactHotLoader) {\n    return;\n  }\n  reactHotLoader.register(Switchboard, \"Switchboard\", \"/Users/aaron/work/superset/superset-frontend/packages/superset-ui-switchboard/src/switchboard.ts\");\n  reactHotLoader.register(isGet, \"isGet\", \"/Users/aaron/work/superset/superset-frontend/packages/superset-ui-switchboard/src/switchboard.ts\");\n  reactHotLoader.register(isReply, \"isReply\", \"/Users/aaron/work/superset/superset-frontend/packages/superset-ui-switchboard/src/switchboard.ts\");\n  reactHotLoader.register(isEmit, \"isEmit\", \"/Users/aaron/work/superset/superset-frontend/packages/superset-ui-switchboard/src/switchboard.ts\");\n  reactHotLoader.register(isError, \"isError\", \"/Users/aaron/work/superset/superset-frontend/packages/superset-ui-switchboard/src/switchboard.ts\");\n})();\n;\n(function () {\n  var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;\n  leaveModule && leaveModule(module);\n})();","map":{"version":3,"names":["enterModule","reactHotLoaderGlobal","undefined","module","__signature__","default","signature","a","Switchboard","_ref","_this","port","_ref$name","name","_ref$debug","debug","_classCallCheck","methods","incrementor","debugMode","addEventListener","_ref2","_asyncToGenerator","_regeneratorRuntime","mark","_callee","event","message","method","args","executor","wrap","_callee$","_context","prev","next","log","data","isGet","t0","getMethodResult","t1","sent","postMessage","call","isEmit","stop","_x","apply","arguments","_createClass","key","value","_getMethodResult","_callee2","_ref3","messageId","result","_callee2$","_context2","abrupt","switchboardAction","Actions","ERROR","error","concat","REPLY","logError","_x2","defineMethod","methodName","get","_this2","length","Promise","resolve","reject","getNewMessageId","listener","removeEventListener","isReply","errStr","isError","Error","start","GET","emit","EMIT","_console","_len","Array","_key","console","_console2","_len2","_key2","__reactstandin__regenerateByEval","code","eval","reactHotLoader","register","leaveModule"],"sources":["/home/system/togo-web-test/node_modules/@superset-ui/switchboard/esm/switchboard.js"],"sourcesContent":["(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;};\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * A utility for communications between an iframe and its parent, used by the Superset embedded SDK.\n * This builds useful patterns on top of the basic functionality offered by MessageChannel.\n *\n * Both windows instantiate a Switchboard, passing in their MessagePorts.\n * Calling methods on the switchboard causes messages to be sent through the channel.\n */\nexport class Switchboard {\n\n\n\n\n\n\n  // used to make unique ids\n\n\n\n\n  constructor({ port, name = 'switchboard', debug = false }) {this.port = void 0;this.name = void 0;this.methods = {};this.incrementor = 1;this.debugMode = void 0;\n    this.port = port;\n    this.name = name;\n    this.debugMode = debug;\n\n    port.addEventListener('message', async (event) => {\n      this.log('message received', event);\n      const message = event.data;\n      if (isGet(message)) {\n        // find the method, call it, and reply with the result\n        this.port.postMessage(await this.getMethodResult(message));\n      } else if (isEmit(message)) {\n        const { method, args } = message;\n        // Find the method and call it, but no result necessary.\n        // Should this multicast to a set of listeners?\n        // Maybe, but that requires writing a bunch more code\n        // and I haven't found a need for it yet.\n        const executor = this.methods[method];\n        if (executor) {\n          executor(args);\n        }\n      }\n    });\n  }\n\n  async getMethodResult({\n    messageId,\n    method,\n    args })\n  {\n    const executor = this.methods[method];\n    if (executor == null) {\n      return {\n        switchboardAction: Actions.ERROR,\n        messageId,\n        error: `[${this.name}] Method \"${method}\" is not defined` };\n\n    }\n    try {\n      const result = await executor(args);\n      return {\n        switchboardAction: Actions.REPLY,\n        messageId,\n        result };\n\n    } catch (err) {\n      this.logError(err);\n      return {\n        switchboardAction: Actions.ERROR,\n        messageId,\n        error: `[${this.name}] Method \"${method}\" threw an error` };\n\n    }\n  }\n\n  /**\n   * Defines a method that can be \"called\" from the other side by sending an event.\n   */\n  defineMethod(methodName, executor) {\n    this.methods[methodName] = executor;\n  }\n\n  /**\n   * Calls a method registered on the other side, and returns the result.\n   *\n   * How this is accomplished:\n   * This switchboard sends a \"get\" message over the channel describing which method to call with which arguments.\n   * The other side's switchboard finds a method with that name, and calls it with the arguments.\n   * It then packages up the returned value into a \"reply\" message, sending it back to us across the channel.\n   * This switchboard has attached a listener on the channel, which will resolve with the result when a reply is detected.\n   *\n   * Instead of an arguments list, arguments are supplied as a map.\n   *\n   * @param method the name of the method to call\n   * @param args arguments that will be supplied. Must be serializable, no functions or other nonense.\n   * @returns whatever is returned from the method\n   */\n  get(method, args = undefined) {\n    return new Promise((resolve, reject) => {\n      // In order to \"call a method\" on the other side of the port,\n      // we will send a message with a unique id\n      const messageId = this.getNewMessageId();\n      // attach a new listener to our port, and remove it when we get a response\n      const listener = (event) => {\n        const message = event.data;\n        if (message.messageId !== messageId) return;\n        this.port.removeEventListener('message', listener);\n        if (isReply(message)) {\n          resolve(message.result);\n        } else {\n          const errStr = isError(message) ?\n          message.error :\n          'Unexpected response message';\n          reject(new Error(errStr));\n        }\n      };\n      this.port.addEventListener('message', listener);\n      this.port.start();\n      const message = {\n        switchboardAction: Actions.GET,\n        method,\n        messageId,\n        args };\n\n      this.port.postMessage(message);\n    });\n  }\n\n  /**\n   * Emit calls a method on the other side just like get does.\n   * But emit doesn't wait for a response, it just sends and forgets.\n   *\n   * @param method\n   * @param args\n   */\n  emit(method, args = undefined) {\n    const message = {\n      switchboardAction: Actions.EMIT,\n      method,\n      args };\n\n    this.port.postMessage(message);\n  }\n\n  start() {\n    this.port.start();\n  }\n\n  log(...args) {\n    if (this.debugMode) {\n      console.debug(`[${this.name}]`, ...args);\n    }\n  }\n\n  logError(...args) {\n    console.error(`[${this.name}]`, ...args);\n  }\n\n  getNewMessageId() {\n    // eslint-disable-next-line no-plusplus\n    return `m_${this.name}_${this.incrementor++}`;\n  } // @ts-ignore\n  __reactstandin__regenerateByEval(key, code) {// @ts-ignore\n    this[key] = eval(code);}}\n\n\n// Each message we send on the channel specifies an action we want the other side to cooperate with.\nvar Actions;\n\n\n\n\n\n\n// helper types/functions for making sure wires don't get crossed\n(function (Actions) {Actions[\"GET\"] = \"get\";Actions[\"REPLY\"] = \"reply\";Actions[\"EMIT\"] = \"emit\";Actions[\"ERROR\"] = \"error\";})(Actions || (Actions = {}));\n\n\n\n\n\n\n\n\n\n\n\nfunction isGet(message) {\n  return message.switchboardAction === Actions.GET;\n}\n\n\n\n\n\n\n\nfunction isReply(message) {\n  return message.switchboardAction === Actions.REPLY;\n}\n\n\n\n\n\n\n\nfunction isEmit(message) {\n  return message.switchboardAction === Actions.EMIT;\n}\n\n\n\n\n\n\n\nfunction isError(message) {\n  return message.switchboardAction === Actions.ERROR;\n};(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(Switchboard, \"Switchboard\", \"/Users/aaron/work/superset/superset-frontend/packages/superset-ui-switchboard/src/switchboard.ts\");reactHotLoader.register(isGet, \"isGet\", \"/Users/aaron/work/superset/superset-frontend/packages/superset-ui-switchboard/src/switchboard.ts\");reactHotLoader.register(isReply, \"isReply\", \"/Users/aaron/work/superset/superset-frontend/packages/superset-ui-switchboard/src/switchboard.ts\");reactHotLoader.register(isEmit, \"isEmit\", \"/Users/aaron/work/superset/superset-frontend/packages/superset-ui-switchboard/src/switchboard.ts\");reactHotLoader.register(isError, \"isError\", \"/Users/aaron/work/superset/superset-frontend/packages/superset-ui-switchboard/src/switchboard.ts\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();"],"mappings":"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"},"metadata":{},"sourceType":"module"}