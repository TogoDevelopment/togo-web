{"ast":null,"code":"import _slicedToArray from \"/home/system/togo-web-test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _toArray from \"/home/system/togo-web-test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toArray\";\nfunction _wrapRegExp(re, groups) {\n  _wrapRegExp = function _wrapRegExp(re, groups) {\n    return new BabelRegExp(re, undefined, groups);\n  };\n  var _RegExp = _wrapNativeSuper(RegExp);\n  var _super = RegExp.prototype;\n  var _groups = new WeakMap();\n  function BabelRegExp(re, flags, groups) {\n    var _this = _RegExp.call(this, re, flags);\n    _groups.set(_this, groups || _groups.get(re));\n    return _this;\n  }\n  _inherits(BabelRegExp, _RegExp);\n  BabelRegExp.prototype.exec = function (str) {\n    var result = _super.exec.call(this, str);\n    if (result) result.groups = buildGroups(result, this);\n    return result;\n  };\n  BabelRegExp.prototype[Symbol.replace] = function (str, substitution) {\n    if (typeof substitution === \"string\") {\n      var groups = _groups.get(this);\n      return _super[Symbol.replace].call(this, str, substitution.replace(/\\$<([^>]+)>/g, function (_, name) {\n        return \"$\" + groups[name];\n      }));\n    } else if (typeof substitution === \"function\") {\n      var _this = this;\n      return _super[Symbol.replace].call(this, str, function () {\n        var args = [];\n        args.push.apply(args, arguments);\n        if (typeof args[args.length - 1] !== \"object\") {\n          args.push(buildGroups(args, _this));\n        }\n        return substitution.apply(this, args);\n      });\n    } else {\n      return _super[Symbol.replace].call(this, str, substitution);\n    }\n  };\n  function buildGroups(result, re) {\n    var g = _groups.get(re);\n    return Object.keys(g).reduce(function (groups, name) {\n      groups[name] = result[g[name]];\n      return groups;\n    }, Object.create(null));\n  }\n  return _wrapRegExp.apply(this, arguments);\n}\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (typeof call === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n  return _assertThisInitialized(self);\n}\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return self;\n}\nfunction _wrapNativeSuper(Class) {\n  var _cache = typeof Map === \"function\" ? new Map() : undefined;\n  _wrapNativeSuper = function _wrapNativeSuper(Class) {\n    if (Class === null || !_isNativeFunction(Class)) return Class;\n    if (typeof Class !== \"function\") {\n      throw new TypeError(\"Super expression must either be null or a function\");\n    }\n    if (typeof _cache !== \"undefined\") {\n      if (_cache.has(Class)) return _cache.get(Class);\n      _cache.set(Class, Wrapper);\n    }\n    function Wrapper() {\n      return _construct(Class, arguments, _getPrototypeOf(this).constructor);\n    }\n    Wrapper.prototype = Object.create(Class.prototype, {\n      constructor: {\n        value: Wrapper,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n    return _setPrototypeOf(Wrapper, Class);\n  };\n  return _wrapNativeSuper(Class);\n}\nfunction _construct(Parent, args, Class) {\n  if (_isNativeReflectConstruct()) {\n    _construct = Reflect.construct;\n  } else {\n    _construct = function _construct(Parent, args, Class) {\n      var a = [null];\n      a.push.apply(a, args);\n      var Constructor = Function.bind.apply(Parent, a);\n      var instance = new Constructor();\n      if (Class) _setPrototypeOf(instance, Class.prototype);\n      return instance;\n    };\n  }\n  return _construct.apply(null, arguments);\n}\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nfunction _isNativeFunction(fn) {\n  return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n}\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n  return _setPrototypeOf(o, p);\n}\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\nimport { isString } from \"@chakra-ui/utils\";\nvar directionMap = {\n  \"to-t\": \"to top\",\n  \"to-tr\": \"to top right\",\n  \"to-r\": \"to right\",\n  \"to-br\": \"to bottom right\",\n  \"to-b\": \"to bottom\",\n  \"to-bl\": \"to bottom left\",\n  \"to-l\": \"to left\",\n  \"to-tl\": \"to top left\"\n};\nvar valueSet = new Set(Object.values(directionMap));\nexport var globalSet = new Set([\"none\", \"-moz-initial\", \"inherit\", \"initial\", \"revert\", \"unset\"]);\nvar trimSpace = function trimSpace(str) {\n  return str.trim();\n};\nexport function parseGradient(value, theme) {\n  var _regex$exec$groups, _regex$exec;\n  if (value == null || globalSet.has(value)) return value;\n  var regex = /*#__PURE__*/_wrapRegExp(/(^[\\x2DA-Za-z]+)\\(((.*))\\)/g, {\n    type: 1,\n    values: 2\n  });\n  var _ref = (_regex$exec$groups = (_regex$exec = regex.exec(value)) == null ? void 0 : _regex$exec.groups) != null ? _regex$exec$groups : {},\n    type = _ref.type,\n    values = _ref.values;\n  if (!type || !values) return value;\n  var _type = type.includes(\"-gradient\") ? type : type + \"-gradient\";\n  var _values$split$map$fil = values.split(\",\").map(trimSpace).filter(Boolean),\n    _values$split$map$fil2 = _toArray(_values$split$map$fil),\n    maybeDirection = _values$split$map$fil2[0],\n    stops = _values$split$map$fil2.slice(1);\n  if ((stops == null ? void 0 : stops.length) === 0) return value;\n  var direction = maybeDirection in directionMap ? directionMap[maybeDirection] : maybeDirection;\n  stops.unshift(direction);\n  var _values = stops.map(function (stop) {\n    // if stop is valid shorthand direction, return it\n    if (valueSet.has(stop)) return stop;\n    var firstStop = stop.indexOf(\" \"); // color stop could be `red.200 20%` based on css gradient spec\n\n    var _ref2 = firstStop !== -1 ? [stop.substr(0, firstStop), stop.substr(firstStop + 1)] : [stop],\n      _ref3 = _slicedToArray(_ref2, 2),\n      _color = _ref3[0],\n      _stop = _ref3[1];\n    var _stopOrFunc = isCSSFunction(_stop) ? _stop : _stop && _stop.split(\" \"); // else, get and transform the color token or css value\n\n    var key = \"colors.\" + _color;\n    var color = key in theme.__cssMap ? theme.__cssMap[key].varRef : _color;\n    return _stopOrFunc ? [color, _stopOrFunc].join(\" \") : color;\n  });\n  return _type + \"(\" + _values.join(\", \") + \")\";\n}\nexport var isCSSFunction = function isCSSFunction(value) {\n  return isString(value) && value.includes(\"(\") && value.includes(\")\");\n};\nexport var gradientTransform = function gradientTransform(value, theme) {\n  return parseGradient(value, theme != null ? theme : {});\n};","map":{"version":3,"names":["isString","directionMap","valueSet","Set","Object","values","globalSet","trimSpace","str","trim","parseGradient","value","theme","_regex$exec$groups","_regex$exec","has","regex","_wrapRegExp","type","_ref","exec","groups","_type","includes","_values$split$map$fil","split","map","filter","Boolean","_values$split$map$fil2","_toArray","maybeDirection","stops","slice","length","direction","unshift","_values","stop","firstStop","indexOf","_ref2","substr","_ref3","_slicedToArray","_color","_stop","_stopOrFunc","isCSSFunction","key","color","__cssMap","varRef","join","gradientTransform"],"sources":["../../../src/utils/parse-gradient.ts"],"sourcesContent":["import { Dict, isString } from \"@chakra-ui/utils\"\nimport { Transform } from \"./types\"\n\nconst directionMap = {\n  \"to-t\": \"to top\",\n  \"to-tr\": \"to top right\",\n  \"to-r\": \"to right\",\n  \"to-br\": \"to bottom right\",\n  \"to-b\": \"to bottom\",\n  \"to-bl\": \"to bottom left\",\n  \"to-l\": \"to left\",\n  \"to-tl\": \"to top left\",\n}\n\nconst valueSet = new Set(Object.values(directionMap))\n\nexport const globalSet = new Set([\n  \"none\",\n  \"-moz-initial\",\n  \"inherit\",\n  \"initial\",\n  \"revert\",\n  \"unset\",\n])\n\nconst trimSpace = (str: string) => str.trim()\n\nexport function parseGradient(value: string | null | undefined, theme: Dict) {\n  if (value == null || globalSet.has(value)) return value\n  const regex = /(?<type>^[a-z-A-Z]+)\\((?<values>(.*))\\)/g\n  const { type, values } = regex.exec(value)?.groups ?? {}\n\n  if (!type || !values) return value\n\n  const _type = type.includes(\"-gradient\") ? type : `${type}-gradient`\n  const [maybeDirection, ...stops] = values\n    .split(\",\")\n    .map(trimSpace)\n    .filter(Boolean)\n\n  if (stops?.length === 0) return value\n\n  const direction =\n    maybeDirection in directionMap\n      ? directionMap[maybeDirection]\n      : maybeDirection\n\n  stops.unshift(direction)\n\n  const _values = stops.map((stop) => {\n    // if stop is valid shorthand direction, return it\n    if (valueSet.has(stop)) return stop\n\n    const firstStop = stop.indexOf(\" \")\n\n    // color stop could be `red.200 20%` based on css gradient spec\n    const [_color, _stop] =\n      firstStop !== -1\n        ? [stop.substr(0, firstStop), stop.substr(firstStop + 1)]\n        : [stop]\n\n    const _stopOrFunc = isCSSFunction(_stop) ? _stop : _stop && _stop.split(\" \")\n\n    // else, get and transform the color token or css value\n    const key = `colors.${_color}`\n    const color = key in theme.__cssMap ? theme.__cssMap[key].varRef : _color\n    return _stopOrFunc ? [color, _stopOrFunc].join(\" \") : color\n  })\n\n  return `${_type}(${_values.join(\", \")})`\n}\n\nexport const isCSSFunction = (value: unknown) => {\n  return isString(value) && value.includes(\"(\") && value.includes(\")\")\n}\n\nexport const gradientTransform: Transform = (value, theme) =>\n  parseGradient(value, theme ?? {})\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,SAAeA,QAAf,QAA+B,kBAA/B;AAGA,IAAMC,YAAY,GAAG;EACnB,QAAQ,QADW;EAEnB,SAAS,cAFU;EAGnB,QAAQ,UAHW;EAInB,SAAS,iBAJU;EAKnB,QAAQ,WALW;EAMnB,SAAS,gBANU;EAOnB,QAAQ,SAPW;EAQnB,SAAS;AARU,CAArB;AAWA,IAAMC,QAAQ,GAAG,IAAIC,GAAJ,CAAQC,MAAM,CAACC,MAAP,CAAcJ,YAAd,CAAR,CAAjB;AAEA,OAAO,IAAMK,SAAS,GAAG,IAAIH,GAAJ,CAAQ,CAC/B,MAD+B,EAE/B,cAF+B,EAG/B,SAH+B,EAI/B,SAJ+B,EAK/B,QAL+B,EAM/B,OAN+B,CAAR,CAAlB;AASP,IAAMI,SAAS,GAAI,SAAbA,SAASA,CAAIC,GAAD;EAAA,OAAiBA,GAAG,CAACC,IAAJ,EAAnC;AAAA;AAEA,OAAO,SAASC,aAATA,CAAuBC,KAAvB,EAAyDC,KAAzD,EAAsE;EAAA,IAAAC,kBAAA,EAAAC,WAAA;EAC3E,IAAIH,KAAK,IAAI,IAAT,IAAiBL,SAAS,CAACS,GAAV,CAAcJ,KAAd,CAArB,EAA2C,OAAOA,KAAP;EAC3C,IAAMK,KAAK,gBAAAC,WAAA,CAAG,6BAAH;IAAAC,IAAA;IAAAb,MAAA;EAAA,EAAX;EACA,IAAAc,IAAA,GAAM,CAAAN,kBAAA,IAAAC,WAAA,GAAmBE,KAAK,CAACI,IAAN,CAAWT,KAAX,CAAnB,qBAAmBG,WAAA,CAAmBO,MAAtC,YAAAR,kBAAA,GAAgD,EAAtD;IAAQK,IAAF,GAAAC,IAAA,CAAED,IAAF;IAAQb,MAAA,GAAAc,IAAA,CAAAd,MAAA;EAEd,IAAI,CAACa,IAAD,IAAS,CAACb,MAAd,EAAsB,OAAOM,KAAP;EAEtB,IAAMW,KAAK,GAAGJ,IAAI,CAACK,QAAL,CAAc,WAAd,IAA6BL,IAA7B,GAAuCA,IAAvC,cAAd;EACA,IAAAM,qBAAA,GAAmCnB,MAAM,CACtCoB,KADgC,CAC1B,GAD0B,EAEhCC,GAFgC,CAE5BnB,SAF4B,EAGhCoB,MAHgC,CAGzBC,OAHyB,CAAnC;IAAAC,sBAAA,GAAAC,QAAA,CAAAN,qBAAA;IAAOO,cAAD,GAAAF,sBAAA;IAAoBG,KAApB,GAAAH,sBAAA,CAAAI,KAAA;EAKN,IAAI,CAAAD,KAAK,QAAL,YAAAA,KAAK,CAAEE,MAAP,MAAkB,CAAtB,EAAyB,OAAOvB,KAAP;EAEzB,IAAMwB,SAAS,GACbJ,cAAc,IAAI9B,YAAlB,GACIA,YAAY,CAAC8B,cAAD,CADhB,GAEIA,cAHN;EAKAC,KAAK,CAACI,OAAN,CAAcD,SAAd;EAEA,IAAME,OAAO,GAAGL,KAAK,CAACN,GAAN,CAAW,UAAAY,IAAD,EAAU;IAClC;IACA,IAAIpC,QAAQ,CAACa,GAAT,CAAauB,IAAb,CAAJ,EAAwB,OAAOA,IAAP;IAExB,IAAMC,SAAS,GAAGD,IAAI,CAACE,OAAL,CAAa,GAAb,CAAlB,CAJkC,CAMlC;;IACA,IAAAC,KAAA,GACEF,SAAS,KAAK,CAAC,CAAf,GACI,CAACD,IAAI,CAACI,MAAL,CAAY,CAAZ,EAAeH,SAAf,CAAD,EAA4BD,IAAI,CAACI,MAAL,CAAYH,SAAS,GAAG,CAAxB,CAA5B,CADJ,GAEI,CAACD,IAAD,CAHN;MAAAK,KAAA,GAAAC,cAAA,CAAAH,KAAA;MAAOI,MAAD,GAAAF,KAAA;MAASG,KAAT,GAAAH,KAAA;IAKN,IAAMI,WAAW,GAAGC,aAAa,CAACF,KAAD,CAAb,GAAuBA,KAAvB,GAA+BA,KAAK,IAAIA,KAAK,CAACrB,KAAN,CAAY,GAAZ,CAA5D,CAZkC,CAclC;;IACA,IAAMwB,GAAG,eAAaJ,MAAtB;IACA,IAAMK,KAAK,GAAGD,GAAG,IAAIrC,KAAK,CAACuC,QAAb,GAAwBvC,KAAK,CAACuC,QAAN,CAAeF,GAAf,EAAoBG,MAA5C,GAAqDP,MAAnE;IACA,OAAOE,WAAW,GAAG,CAACG,KAAD,EAAQH,WAAR,EAAqBM,IAArB,CAA0B,GAA1B,CAAH,GAAoCH,KAAtD;EACD,CAlBe,CAAhB;EAoBA,OAAU5B,KAAV,SAAmBe,OAAO,CAACgB,IAAR,CAAa,IAAb,CAAnB;AACD;AAED,OAAO,IAAML,aAAa,GAAI,SAAjBA,aAAaA,CAAIrC,KAAD,EAAoB;EAC/C,OAAOX,QAAQ,CAACW,KAAD,CAAR,IAAmBA,KAAK,CAACY,QAAN,CAAe,GAAf,CAAnB,IAA0CZ,KAAK,CAACY,QAAN,CAAe,GAAf,CAAjD;AACD,CAFM;AAIP,OAAO,IAAM+B,iBAA4B,GAAG,SAA/BA,iBAA4BA,CAAI3C,KAAD,EAAQC,KAAR;EAAA,OAC1CF,aAAa,CAACC,KAAD,EAAQC,KAAR,WAAQA,KAAR,GAAiB,EAAjB,CADR;AAAA"},"metadata":{},"sourceType":"module"}