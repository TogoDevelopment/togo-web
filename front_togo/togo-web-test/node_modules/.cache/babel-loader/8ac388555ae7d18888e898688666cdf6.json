{"ast":null,"code":"import _defineProperty from \"/home/system/togo-web-test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport _slicedToArray from \"/home/system/togo-web-test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n  return target;\n}\nimport { useClickable } from \"@chakra-ui/clickable\";\nimport { createDescendantContext } from \"@chakra-ui/descendant\";\nimport { useControllableState, useId, useSafeLayoutEffect } from \"@chakra-ui/hooks\";\nimport { createContext, getValidChildren, mergeRefs } from \"@chakra-ui/react-utils\";\nimport { callAllHandlers, determineLazyBehavior, focus, isUndefined, normalizeEventKey } from \"@chakra-ui/utils\";\nimport * as React from \"react\";\n/* -------------------------------------------------------------------------------------------------\n * Create context to track descendants and their indices\n * -----------------------------------------------------------------------------------------------*/\n\nvar _createDescendantCont = createDescendantContext(),\n  _createDescendantCont2 = _slicedToArray(_createDescendantCont, 4),\n  TabsDescendantsProvider = _createDescendantCont2[0],\n  useTabsDescendantsContext = _createDescendantCont2[1],\n  useTabsDescendants = _createDescendantCont2[2],\n  useTabsDescendant = _createDescendantCont2[3];\n/* -------------------------------------------------------------------------------------------------\n * useTabs - The root react hook that manages all tab items\n * -----------------------------------------------------------------------------------------------*/\n\n/**\n * Tabs hooks that provides all the states, and accessibility\n * helpers to keep all things working properly.\n *\n * Its returned object will be passed unto a Context Provider\n * so all child components can read from it.\n * There is no document link yet\n * @see Docs https://chakra-ui.com/docs/components/useTabs\n */\nexport { TabsDescendantsProvider, useTabsDescendantsContext, useTabsDescendants, useTabsDescendant };\nexport function useTabs(props) {\n  var defaultIndex = props.defaultIndex,\n    onChange = props.onChange,\n    index = props.index,\n    isManual = props.isManual,\n    isLazy = props.isLazy,\n    _props$lazyBehavior = props.lazyBehavior,\n    lazyBehavior = _props$lazyBehavior === void 0 ? \"unmount\" : _props$lazyBehavior,\n    _props$orientation = props.orientation,\n    orientation = _props$orientation === void 0 ? \"horizontal\" : _props$orientation,\n    _props$direction = props.direction,\n    direction = _props$direction === void 0 ? \"ltr\" : _props$direction,\n    htmlProps = _objectWithoutPropertiesLoose(props, [\"defaultIndex\", \"onChange\", \"index\", \"isManual\", \"isLazy\", \"lazyBehavior\", \"orientation\", \"direction\"]);\n  /**\n   * We use this to keep track of the index of the focused tab.\n   *\n   * Tabs can be automatically activated, this means selection follows focus.\n   * When we navigate with the arrow keys, we move focus and selection to next/prev tab\n   *\n   * Tabs can also be manually activated, this means selection does not follow focus.\n   * When we navigate with the arrow keys, we only move focus NOT selection. The user\n   * will need not manually activate the tab using `Enter` or `Space`.\n   *\n   * This is why we need to keep track of the `focusedIndex` and `selectedIndex`\n   */\n\n  var _React$useState = React.useState(defaultIndex != null ? defaultIndex : 0),\n    _React$useState2 = _slicedToArray(_React$useState, 2),\n    focusedIndex = _React$useState2[0],\n    setFocusedIndex = _React$useState2[1];\n  var _useControllableState = useControllableState({\n      defaultValue: defaultIndex != null ? defaultIndex : 0,\n      value: index,\n      onChange: onChange\n    }),\n    _useControllableState2 = _slicedToArray(_useControllableState, 2),\n    selectedIndex = _useControllableState2[0],\n    setSelectedIndex = _useControllableState2[1];\n  /**\n   * Sync focused `index` with controlled `selectedIndex` (which is the `props.index`)\n   */\n\n  React.useEffect(function () {\n    if (index != null) {\n      setFocusedIndex(index);\n    }\n  }, [index]);\n  /**\n   * Think of `useDescendants` as a register for the tab nodes.\n   */\n\n  var descendants = useTabsDescendants();\n  /**\n   * Generate a unique id or use user-provided id for the tabs widget\n   */\n\n  var id = useId(props.id, \"tabs\");\n  return {\n    id: id,\n    selectedIndex: selectedIndex,\n    focusedIndex: focusedIndex,\n    setSelectedIndex: setSelectedIndex,\n    setFocusedIndex: setFocusedIndex,\n    isManual: isManual,\n    isLazy: isLazy,\n    lazyBehavior: lazyBehavior,\n    orientation: orientation,\n    descendants: descendants,\n    direction: direction,\n    htmlProps: htmlProps\n  };\n}\nvar _createContext = createContext({\n    name: \"TabsContext\",\n    errorMessage: \"useTabsContext: `context` is undefined. Seems you forgot to wrap all tabs components within <Tabs />\"\n  }),\n  _createContext2 = _slicedToArray(_createContext, 2),\n  TabsProvider = _createContext2[0],\n  useTabsContext = _createContext2[1];\n\n/**\n * Tabs hook to manage multiple tab buttons,\n * and ensures only one tab is selected per time.\n *\n * @param props props object for the tablist\n */\nexport { TabsProvider, useTabsContext };\nexport function useTabList(props) {\n  var _useTabsContext = useTabsContext(),\n    focusedIndex = _useTabsContext.focusedIndex,\n    orientation = _useTabsContext.orientation,\n    direction = _useTabsContext.direction;\n  var descendants = useTabsDescendantsContext();\n  var onKeyDown = React.useCallback(function (event) {\n    var _keyMap;\n    var nextTab = function nextTab() {\n      var next = descendants.nextEnabled(focusedIndex);\n      if (next) focus(next.node);\n    };\n    var prevTab = function prevTab() {\n      var prev = descendants.prevEnabled(focusedIndex);\n      if (prev) focus(prev.node);\n    };\n    var firstTab = function firstTab() {\n      var first = descendants.firstEnabled();\n      if (first) focus(first.node);\n    };\n    var lastTab = function lastTab() {\n      var last = descendants.lastEnabled();\n      if (last) focus(last.node);\n    };\n    var isHorizontal = orientation === \"horizontal\";\n    var isVertical = orientation === \"vertical\";\n    var eventKey = normalizeEventKey(event);\n    var ArrowStart = direction === \"ltr\" ? \"ArrowLeft\" : \"ArrowRight\";\n    var ArrowEnd = direction === \"ltr\" ? \"ArrowRight\" : \"ArrowLeft\";\n    var keyMap = (_keyMap = {}, _defineProperty(_keyMap, ArrowStart, function () {\n      return isHorizontal && prevTab();\n    }), _defineProperty(_keyMap, ArrowEnd, function () {\n      return isHorizontal && nextTab();\n    }), _defineProperty(_keyMap, \"ArrowDown\", function ArrowDown() {\n      return isVertical && nextTab();\n    }), _defineProperty(_keyMap, \"ArrowUp\", function ArrowUp() {\n      return isVertical && prevTab();\n    }), _defineProperty(_keyMap, \"Home\", firstTab), _defineProperty(_keyMap, \"End\", lastTab), _keyMap);\n    var action = keyMap[eventKey];\n    if (action) {\n      event.preventDefault();\n      action(event);\n    }\n  }, [descendants, focusedIndex, orientation, direction]);\n  return _extends({}, props, {\n    role: \"tablist\",\n    \"aria-orientation\": orientation,\n    onKeyDown: callAllHandlers(props.onKeyDown, onKeyDown)\n  });\n}\n\n/**\n * Tabs hook to manage each tab button.\n *\n * A tab can be disabled and focusable, or both,\n * hence the use of `useClickable` to handle this scenario\n */\nexport function useTab(props) {\n  var isDisabled = props.isDisabled,\n    isFocusable = props.isFocusable,\n    htmlProps = _objectWithoutPropertiesLoose(props, [\"isDisabled\", \"isFocusable\"]);\n  var _useTabsContext2 = useTabsContext(),\n    setSelectedIndex = _useTabsContext2.setSelectedIndex,\n    isManual = _useTabsContext2.isManual,\n    id = _useTabsContext2.id,\n    setFocusedIndex = _useTabsContext2.setFocusedIndex,\n    selectedIndex = _useTabsContext2.selectedIndex;\n  var _useTabsDescendant = useTabsDescendant({\n      disabled: isDisabled && !isFocusable\n    }),\n    index = _useTabsDescendant.index,\n    register = _useTabsDescendant.register;\n  var isSelected = index === selectedIndex;\n  var onClick = function onClick() {\n    setSelectedIndex(index);\n  };\n  var onFocus = function onFocus() {\n    setFocusedIndex(index);\n    var isDisabledButFocusable = isDisabled && isFocusable;\n    var shouldSelect = !isManual && !isDisabledButFocusable;\n    if (shouldSelect) {\n      setSelectedIndex(index);\n    }\n  };\n  var clickableProps = useClickable(_extends({}, htmlProps, {\n    ref: mergeRefs(register, props.ref),\n    isDisabled: isDisabled,\n    isFocusable: isFocusable,\n    onClick: callAllHandlers(props.onClick, onClick)\n  }));\n  var type = \"button\";\n  return _extends({}, clickableProps, {\n    id: makeTabId(id, index),\n    role: \"tab\",\n    tabIndex: isSelected ? 0 : -1,\n    type: type,\n    \"aria-selected\": isSelected,\n    \"aria-controls\": makeTabPanelId(id, index),\n    onFocus: isDisabled ? undefined : callAllHandlers(props.onFocus, onFocus)\n  });\n}\n\n/**\n * Tabs hook for managing the visibility of multiple tab panels.\n *\n * Since only one panel can be show at a time, we use `cloneElement`\n * to inject `selected` panel to each TabPanel.\n *\n * It returns a cloned version of its children with\n * all functionality included.\n */\nexport function useTabPanels(props) {\n  var context = useTabsContext();\n  var id = context.id,\n    selectedIndex = context.selectedIndex;\n  var validChildren = getValidChildren(props.children);\n  var children = validChildren.map(function (child, index) {\n    return /*#__PURE__*/React.cloneElement(child, {\n      isSelected: index === selectedIndex,\n      id: makeTabPanelId(id, index),\n      // Refers to the associated tab element, and also provides an accessible name to the tab panel.\n      \"aria-labelledby\": makeTabId(id, index)\n    });\n  });\n  return _extends({}, props, {\n    children: children\n  });\n}\n/**\n * Tabs hook for managing the visible/hidden states\n * of the tab panel.\n *\n * @param props props object for the tab panel\n */\n\nexport function useTabPanel(props) {\n  var isSelected = props.isSelected,\n    id = props.id,\n    children = props.children,\n    htmlProps = _objectWithoutPropertiesLoose(props, [\"isSelected\", \"id\", \"children\"]);\n  var _useTabsContext3 = useTabsContext(),\n    isLazy = _useTabsContext3.isLazy,\n    lazyBehavior = _useTabsContext3.lazyBehavior;\n  var hasBeenSelected = React.useRef(false);\n  if (isSelected) {\n    hasBeenSelected.current = true;\n  }\n  var shouldRenderChildren = determineLazyBehavior({\n    hasBeenSelected: hasBeenSelected.current,\n    isSelected: isSelected,\n    isLazy: isLazy,\n    lazyBehavior: lazyBehavior\n  });\n  return _extends({\n    // Puts the tabpanel in the page `Tab` sequence.\n    tabIndex: 0\n  }, htmlProps, {\n    children: shouldRenderChildren ? children : null,\n    role: \"tabpanel\",\n    hidden: !isSelected,\n    id: id\n  });\n}\n/**\n * Tabs hook to show an animated indicators that\n * follows the active tab.\n *\n * The way we do it is by measuring the DOM Rect (or dimensions)\n * of the active tab, and return that as CSS style for\n * the indicator.\n */\n\nexport function useTabIndicator() {\n  var context = useTabsContext();\n  var descendants = useTabsDescendantsContext();\n  var selectedIndex = context.selectedIndex,\n    orientation = context.orientation;\n  var isHorizontal = orientation === \"horizontal\";\n  var isVertical = orientation === \"vertical\"; // Get the clientRect of the selected tab\n\n  var _React$useState3 = React.useState(function () {\n      if (isHorizontal) return {\n        left: 0,\n        width: 0\n      };\n      if (isVertical) return {\n        top: 0,\n        height: 0\n      };\n      return undefined;\n    }),\n    _React$useState4 = _slicedToArray(_React$useState3, 2),\n    rect = _React$useState4[0],\n    setRect = _React$useState4[1];\n  var _React$useState5 = React.useState(false),\n    _React$useState6 = _slicedToArray(_React$useState5, 2),\n    hasMeasured = _React$useState6[0],\n    setHasMeasured = _React$useState6[1]; // Update the selected tab rect when the selectedIndex changes\n\n  useSafeLayoutEffect(function () {\n    if (isUndefined(selectedIndex)) return undefined;\n    var tab = descendants.item(selectedIndex);\n    if (isUndefined(tab)) return undefined; // Horizontal Tab: Calculate width and left distance\n\n    if (isHorizontal) {\n      setRect({\n        left: tab.node.offsetLeft,\n        width: tab.node.offsetWidth\n      });\n    } // Vertical Tab: Calculate height and top distance\n\n    if (isVertical) {\n      setRect({\n        top: tab.node.offsetTop,\n        height: tab.node.offsetHeight\n      });\n    } // Prevent unwanted transition from 0 to measured rect\n    // by setting the measured state in the next tick\n\n    var id = requestAnimationFrame(function () {\n      setHasMeasured(true);\n    });\n    return function () {\n      if (id) {\n        cancelAnimationFrame(id);\n      }\n    };\n  }, [selectedIndex, isHorizontal, isVertical, descendants]);\n  return _extends({\n    position: \"absolute\",\n    transitionProperty: \"left, right, top, bottom\",\n    transitionDuration: hasMeasured ? \"200ms\" : \"0ms\",\n    transitionTimingFunction: \"cubic-bezier(0, 0, 0.2, 1)\"\n  }, rect);\n}\nfunction makeTabId(id, index) {\n  return id + \"--tab-\" + index;\n}\nfunction makeTabPanelId(id, index) {\n  return id + \"--tabpanel-\" + index;\n}","map":{"version":3,"names":["useClickable","createDescendantContext","useControllableState","useId","useSafeLayoutEffect","createContext","getValidChildren","mergeRefs","callAllHandlers","determineLazyBehavior","focus","isUndefined","normalizeEventKey","React","_createDescendantCont","_createDescendantCont2","_slicedToArray","TabsDescendantsProvider","useTabsDescendantsContext","useTabsDescendants","useTabsDescendant","useTabs","props","defaultIndex","onChange","index","isManual","isLazy","_props$lazyBehavior","lazyBehavior","_props$orientation","orientation","_props$direction","direction","htmlProps","_objectWithoutPropertiesLoose","_React$useState","useState","_React$useState2","focusedIndex","setFocusedIndex","_useControllableState","defaultValue","value","_useControllableState2","selectedIndex","setSelectedIndex","useEffect","descendants","id","_createContext","name","errorMessage","_createContext2","TabsProvider","useTabsContext","useTabList","_useTabsContext","onKeyDown","useCallback","event","_keyMap","nextTab","next","nextEnabled","node","prevTab","prev","prevEnabled","firstTab","first","firstEnabled","lastTab","last","lastEnabled","isHorizontal","isVertical","eventKey","ArrowStart","ArrowEnd","keyMap","_defineProperty","ArrowDown","ArrowUp","action","preventDefault","_extends","role","useTab","isDisabled","isFocusable","_useTabsContext2","_useTabsDescendant","disabled","register","isSelected","onClick","onFocus","isDisabledButFocusable","shouldSelect","clickableProps","ref","type","makeTabId","tabIndex","makeTabPanelId","undefined","useTabPanels","context","validChildren","children","map","child","cloneElement","useTabPanel","_useTabsContext3","hasBeenSelected","useRef","current","shouldRenderChildren","hidden","useTabIndicator","_React$useState3","left","width","top","height","_React$useState4","rect","setRect","_React$useState5","_React$useState6","hasMeasured","setHasMeasured","tab","item","offsetLeft","offsetWidth","offsetTop","offsetHeight","requestAnimationFrame","cancelAnimationFrame","position","transitionProperty","transitionDuration","transitionTimingFunction"],"sources":["../../src/use-tabs.ts"],"sourcesContent":["import { useClickable, UseClickableProps } from \"@chakra-ui/clickable\"\nimport { createDescendantContext } from \"@chakra-ui/descendant\"\nimport {\n  useControllableState,\n  useId,\n  useSafeLayoutEffect,\n} from \"@chakra-ui/hooks\"\nimport {\n  createContext,\n  EventKeyMap,\n  getValidChildren,\n  mergeRefs,\n} from \"@chakra-ui/react-utils\"\nimport {\n  callAllHandlers,\n  determineLazyBehavior,\n  Dict,\n  focus,\n  isUndefined,\n  LazyBehavior,\n  normalizeEventKey,\n} from \"@chakra-ui/utils\"\nimport * as React from \"react\"\n\n/* -------------------------------------------------------------------------------------------------\n * Create context to track descendants and their indices\n * -----------------------------------------------------------------------------------------------*/\n\nexport const [\n  TabsDescendantsProvider,\n  useTabsDescendantsContext,\n  useTabsDescendants,\n  useTabsDescendant,\n] = createDescendantContext<HTMLButtonElement>()\n\n/* -------------------------------------------------------------------------------------------------\n * useTabs - The root react hook that manages all tab items\n * -----------------------------------------------------------------------------------------------*/\n\nexport interface UseTabsProps {\n  /**\n   * The orientation of the tab list.\n   */\n  orientation?: \"vertical\" | \"horizontal\"\n  /**\n   * If `true`, the tabs will be manually activated and\n   * display its panel by pressing Space or Enter.\n   *\n   * If `false`, the tabs will be automatically activated\n   * and their panel is displayed when they receive focus.\n   */\n  isManual?: boolean\n  /**\n   * Callback when the index (controlled or un-controlled) changes.\n   */\n  onChange?: (index: number) => void\n  /**\n   * The index of the selected tab (in controlled mode)\n   */\n  index?: number\n  /**\n   * The initial index of the selected tab (in uncontrolled mode)\n   */\n  defaultIndex?: number\n  /**\n   * The id of the tab\n   */\n  id?: string\n  /**\n   * Performance ðŸš€:\n   * If `true`, rendering of the tab panel's will be deferred until it is selected.\n   */\n  isLazy?: boolean\n  /**\n   * Performance ðŸš€:\n   * The lazy behavior of tab panels' content when not active.\n   * Only works when `isLazy={true}`\n   *\n   * - \"unmount\": The content of inactive tab panels are always unmounted.\n   * - \"keepMounted\": The content of inactive tab panels is initially unmounted,\n   * but stays mounted when selected.\n   *\n   * @default \"unmount\"\n   */\n  lazyBehavior?: LazyBehavior\n  /**\n   * The writing mode direction.\n   *\n   * - When in RTL, the left and right navigation is flipped\n   */\n  direction?: \"rtl\" | \"ltr\"\n}\n\n/**\n * Tabs hooks that provides all the states, and accessibility\n * helpers to keep all things working properly.\n *\n * Its returned object will be passed unto a Context Provider\n * so all child components can read from it.\n * There is no document link yet\n * @see Docs https://chakra-ui.com/docs/components/useTabs\n */\nexport function useTabs(props: UseTabsProps) {\n  const {\n    defaultIndex,\n    onChange,\n    index,\n    isManual,\n    isLazy,\n    lazyBehavior = \"unmount\",\n    orientation = \"horizontal\",\n    direction = \"ltr\",\n    ...htmlProps\n  } = props\n\n  /**\n   * We use this to keep track of the index of the focused tab.\n   *\n   * Tabs can be automatically activated, this means selection follows focus.\n   * When we navigate with the arrow keys, we move focus and selection to next/prev tab\n   *\n   * Tabs can also be manually activated, this means selection does not follow focus.\n   * When we navigate with the arrow keys, we only move focus NOT selection. The user\n   * will need not manually activate the tab using `Enter` or `Space`.\n   *\n   * This is why we need to keep track of the `focusedIndex` and `selectedIndex`\n   */\n  const [focusedIndex, setFocusedIndex] = React.useState(defaultIndex ?? 0)\n\n  const [selectedIndex, setSelectedIndex] = useControllableState({\n    defaultValue: defaultIndex ?? 0,\n    value: index,\n    onChange,\n  })\n\n  /**\n   * Sync focused `index` with controlled `selectedIndex` (which is the `props.index`)\n   */\n  React.useEffect(() => {\n    if (index != null) {\n      setFocusedIndex(index)\n    }\n  }, [index])\n\n  /**\n   * Think of `useDescendants` as a register for the tab nodes.\n   */\n  const descendants = useTabsDescendants()\n\n  /**\n   * Generate a unique id or use user-provided id for the tabs widget\n   */\n  const id = useId(props.id, `tabs`)\n\n  return {\n    id,\n    selectedIndex,\n    focusedIndex,\n    setSelectedIndex,\n    setFocusedIndex,\n    isManual,\n    isLazy,\n    lazyBehavior,\n    orientation,\n    descendants,\n    direction,\n    htmlProps,\n  }\n}\n\nexport type UseTabsReturn = Omit<\n  ReturnType<typeof useTabs>,\n  \"htmlProps\" | \"descendants\"\n>\n\nexport const [TabsProvider, useTabsContext] = createContext<UseTabsReturn>({\n  name: \"TabsContext\",\n  errorMessage:\n    \"useTabsContext: `context` is undefined. Seems you forgot to wrap all tabs components within <Tabs />\",\n})\n\ntype Child = React.ReactElement<any>\n\nexport interface UseTabListProps {\n  children?: React.ReactNode\n  onKeyDown?: React.KeyboardEventHandler\n  ref?: React.Ref<any>\n}\n\n/**\n * Tabs hook to manage multiple tab buttons,\n * and ensures only one tab is selected per time.\n *\n * @param props props object for the tablist\n */\nexport function useTabList<P extends UseTabListProps>(props: P) {\n  const { focusedIndex, orientation, direction } = useTabsContext()\n\n  const descendants = useTabsDescendantsContext()\n\n  const onKeyDown = React.useCallback(\n    (event: React.KeyboardEvent) => {\n      const nextTab = () => {\n        const next = descendants.nextEnabled(focusedIndex)\n        if (next) focus(next.node)\n      }\n      const prevTab = () => {\n        const prev = descendants.prevEnabled(focusedIndex)\n        if (prev) focus(prev.node)\n      }\n      const firstTab = () => {\n        const first = descendants.firstEnabled()\n        if (first) focus(first.node)\n      }\n      const lastTab = () => {\n        const last = descendants.lastEnabled()\n        if (last) focus(last.node)\n      }\n\n      const isHorizontal = orientation === \"horizontal\"\n      const isVertical = orientation === \"vertical\"\n\n      const eventKey = normalizeEventKey(event)\n\n      const ArrowStart = direction === \"ltr\" ? \"ArrowLeft\" : \"ArrowRight\"\n      const ArrowEnd = direction === \"ltr\" ? \"ArrowRight\" : \"ArrowLeft\"\n\n      const keyMap: EventKeyMap = {\n        [ArrowStart]: () => isHorizontal && prevTab(),\n        [ArrowEnd]: () => isHorizontal && nextTab(),\n        ArrowDown: () => isVertical && nextTab(),\n        ArrowUp: () => isVertical && prevTab(),\n        Home: firstTab,\n        End: lastTab,\n      }\n\n      const action = keyMap[eventKey]\n\n      if (action) {\n        event.preventDefault()\n        action(event)\n      }\n    },\n    [descendants, focusedIndex, orientation, direction],\n  )\n\n  return {\n    ...props,\n    role: \"tablist\",\n    \"aria-orientation\": orientation,\n    onKeyDown: callAllHandlers(props.onKeyDown, onKeyDown),\n  }\n}\n\nexport type UseTabListReturn = ReturnType<typeof useTabList>\n\nexport interface UseTabOptions {\n  id?: string\n  isSelected?: boolean\n  panelId?: string\n  /**\n   * If `true`, the `Tab` won't be toggleable\n   */\n  isDisabled?: boolean\n}\n\nexport interface UseTabProps\n  extends Omit<UseClickableProps, \"color\">,\n    UseTabOptions {}\n\n/**\n * Tabs hook to manage each tab button.\n *\n * A tab can be disabled and focusable, or both,\n * hence the use of `useClickable` to handle this scenario\n */\nexport function useTab<P extends UseTabProps>(props: P) {\n  const { isDisabled, isFocusable, ...htmlProps } = props\n\n  const {\n    setSelectedIndex,\n    isManual,\n    id,\n    setFocusedIndex,\n    selectedIndex,\n  } = useTabsContext()\n\n  const { index, register } = useTabsDescendant({\n    disabled: isDisabled && !isFocusable,\n  })\n\n  const isSelected = index === selectedIndex\n\n  const onClick = () => {\n    setSelectedIndex(index)\n  }\n\n  const onFocus = () => {\n    setFocusedIndex(index)\n    const isDisabledButFocusable = isDisabled && isFocusable\n    const shouldSelect = !isManual && !isDisabledButFocusable\n    if (shouldSelect) {\n      setSelectedIndex(index)\n    }\n  }\n\n  const clickableProps = useClickable({\n    ...htmlProps,\n    ref: mergeRefs(register, props.ref),\n    isDisabled,\n    isFocusable,\n    onClick: callAllHandlers(props.onClick, onClick),\n  })\n\n  const type: \"button\" | \"submit\" | \"reset\" = \"button\"\n\n  return {\n    ...clickableProps,\n    id: makeTabId(id, index),\n    role: \"tab\",\n    tabIndex: isSelected ? 0 : -1,\n    type,\n    \"aria-selected\": isSelected,\n    \"aria-controls\": makeTabPanelId(id, index),\n    onFocus: isDisabled ? undefined : callAllHandlers(props.onFocus, onFocus),\n  }\n}\n\nexport interface UseTabPanelsProps {\n  children?: React.ReactNode\n}\n\n/**\n * Tabs hook for managing the visibility of multiple tab panels.\n *\n * Since only one panel can be show at a time, we use `cloneElement`\n * to inject `selected` panel to each TabPanel.\n *\n * It returns a cloned version of its children with\n * all functionality included.\n */\nexport function useTabPanels<P extends UseTabPanelsProps>(props: P) {\n  const context = useTabsContext()\n\n  const { id, selectedIndex } = context\n\n  const validChildren = getValidChildren(props.children)\n\n  const children = validChildren.map((child, index) =>\n    React.cloneElement(child as Child, {\n      isSelected: index === selectedIndex,\n      id: makeTabPanelId(id, index),\n      // Refers to the associated tab element, and also provides an accessible name to the tab panel.\n      \"aria-labelledby\": makeTabId(id, index),\n    }),\n  )\n\n  return { ...props, children }\n}\n\n/**\n * Tabs hook for managing the visible/hidden states\n * of the tab panel.\n *\n * @param props props object for the tab panel\n */\nexport function useTabPanel(props: Dict) {\n  const { isSelected, id, children, ...htmlProps } = props\n  const { isLazy, lazyBehavior } = useTabsContext()\n\n  const hasBeenSelected = React.useRef(false)\n  if (isSelected) {\n    hasBeenSelected.current = true\n  }\n\n  const shouldRenderChildren = determineLazyBehavior({\n    hasBeenSelected: hasBeenSelected.current,\n    isSelected,\n    isLazy,\n    lazyBehavior,\n  })\n\n  return {\n    // Puts the tabpanel in the page `Tab` sequence.\n    tabIndex: 0,\n    ...htmlProps,\n    children: shouldRenderChildren ? children : null,\n    role: \"tabpanel\",\n    hidden: !isSelected,\n    id,\n  }\n}\n\n/**\n * Tabs hook to show an animated indicators that\n * follows the active tab.\n *\n * The way we do it is by measuring the DOM Rect (or dimensions)\n * of the active tab, and return that as CSS style for\n * the indicator.\n */\nexport function useTabIndicator(): React.CSSProperties {\n  const context = useTabsContext()\n  const descendants = useTabsDescendantsContext()\n\n  const { selectedIndex, orientation } = context\n\n  const isHorizontal = orientation === \"horizontal\"\n  const isVertical = orientation === \"vertical\"\n\n  // Get the clientRect of the selected tab\n  const [rect, setRect] = React.useState(() => {\n    if (isHorizontal) return { left: 0, width: 0 }\n    if (isVertical) return { top: 0, height: 0 }\n    return undefined\n  })\n\n  const [hasMeasured, setHasMeasured] = React.useState(false)\n\n  // Update the selected tab rect when the selectedIndex changes\n  useSafeLayoutEffect(() => {\n    if (isUndefined(selectedIndex)) return undefined\n\n    const tab = descendants.item(selectedIndex)\n    if (isUndefined(tab)) return undefined\n\n    // Horizontal Tab: Calculate width and left distance\n    if (isHorizontal) {\n      setRect({ left: tab.node.offsetLeft, width: tab.node.offsetWidth })\n    }\n\n    // Vertical Tab: Calculate height and top distance\n    if (isVertical) {\n      setRect({ top: tab.node.offsetTop, height: tab.node.offsetHeight })\n    }\n\n    // Prevent unwanted transition from 0 to measured rect\n    // by setting the measured state in the next tick\n    const id = requestAnimationFrame(() => {\n      setHasMeasured(true)\n    })\n\n    return () => {\n      if (id) {\n        cancelAnimationFrame(id)\n      }\n    }\n  }, [selectedIndex, isHorizontal, isVertical, descendants])\n\n  return {\n    position: \"absolute\",\n    transitionProperty: \"left, right, top, bottom\",\n    transitionDuration: hasMeasured ? \"200ms\" : \"0ms\",\n    transitionTimingFunction: \"cubic-bezier(0, 0, 0.2, 1)\",\n    ...rect,\n  }\n}\n\nfunction makeTabId(id: string, index: number) {\n  return `${id}--tab-${index}`\n}\n\nfunction makeTabPanelId(id: string, index: number) {\n  return `${id}--tabpanel-${index}`\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}