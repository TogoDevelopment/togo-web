{"ast":null,"code":"import _slicedToArray from \"/home/system/togo-web-test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n  return target;\n}\nimport { useBoolean, useCallbackRef, useControllableState, useDimensions, useIds, useLatestRef, usePanGesture, useUpdateEffect } from \"@chakra-ui/hooks\";\nimport { mergeRefs } from \"@chakra-ui/react-utils\";\nimport { ariaAttr, callAllHandlers, clampValue, dataAttr, focus, getBox, normalizeEventKey, percentToValue, roundValueToStep, valueToPercent } from \"@chakra-ui/utils\";\nimport { useCallback, useMemo, useRef } from \"react\";\nimport { getPartsStyle, getIsReversed } from \"./slider-utils\";\n\n/**\n * React hook that implements an accessible range slider.\n *\n * It is an alternative to `<input type=\"range\" />`, and returns\n * prop getters for the component parts\n *\n * @see Docs     https://chakra-ui.com/docs/form/slider\n * @see WAI-ARIA https://www.w3.org/TR/wai-aria-practices-1.1/#slider\n */\nexport function useSlider(props) {\n  var _getAriaValueText;\n  var _props$min = props.min,\n    min = _props$min === void 0 ? 0 : _props$min,\n    _props$max = props.max,\n    max = _props$max === void 0 ? 100 : _props$max,\n    onChange = props.onChange,\n    valueProp = props.value,\n    defaultValue = props.defaultValue,\n    isReversedProp = props.isReversed,\n    _props$direction = props.direction,\n    direction = _props$direction === void 0 ? \"ltr\" : _props$direction,\n    _props$orientation = props.orientation,\n    orientation = _props$orientation === void 0 ? \"horizontal\" : _props$orientation,\n    idProp = props.id,\n    isDisabled = props.isDisabled,\n    isReadOnly = props.isReadOnly,\n    onChangeStartProp = props.onChangeStart,\n    onChangeEndProp = props.onChangeEnd,\n    _props$step = props.step,\n    step = _props$step === void 0 ? 1 : _props$step,\n    getAriaValueTextProp = props.getAriaValueText,\n    ariaValueText = props[\"aria-valuetext\"],\n    ariaLabel = props[\"aria-label\"],\n    ariaLabelledBy = props[\"aria-labelledby\"],\n    name = props.name,\n    _props$focusThumbOnCh = props.focusThumbOnChange,\n    focusThumbOnChange = _props$focusThumbOnCh === void 0 ? true : _props$focusThumbOnCh,\n    htmlProps = _objectWithoutPropertiesLoose(props, [\"min\", \"max\", \"onChange\", \"value\", \"defaultValue\", \"isReversed\", \"direction\", \"orientation\", \"id\", \"isDisabled\", \"isReadOnly\", \"onChangeStart\", \"onChangeEnd\", \"step\", \"getAriaValueText\", \"aria-valuetext\", \"aria-label\", \"aria-labelledby\", \"name\", \"focusThumbOnChange\"]);\n  var onChangeStart = useCallbackRef(onChangeStartProp);\n  var onChangeEnd = useCallbackRef(onChangeEndProp);\n  var getAriaValueText = useCallbackRef(getAriaValueTextProp);\n  var isReversed = getIsReversed({\n    isReversed: isReversedProp,\n    direction: direction,\n    orientation: orientation\n  });\n  /**\n   * Enable the slider handle controlled and uncontrolled scenarios\n   */\n\n  var _useControllableState = useControllableState({\n      value: valueProp,\n      defaultValue: defaultValue != null ? defaultValue : getDefaultValue(min, max),\n      onChange: onChange\n    }),\n    _useControllableState2 = _slicedToArray(_useControllableState, 2),\n    computedValue = _useControllableState2[0],\n    setValue = _useControllableState2[1];\n  var _useBoolean = useBoolean(),\n    _useBoolean2 = _slicedToArray(_useBoolean, 2),\n    isDragging = _useBoolean2[0],\n    setDragging = _useBoolean2[1];\n  var _useBoolean3 = useBoolean(),\n    _useBoolean4 = _slicedToArray(_useBoolean3, 2),\n    isFocused = _useBoolean4[0],\n    setFocused = _useBoolean4[1];\n  var eventSourceRef = useRef(null);\n  var isInteractive = !(isDisabled || isReadOnly);\n  /**\n   * Constrain the value because it can't be less than min\n   * or greater than max\n   */\n\n  var value = clampValue(computedValue, min, max);\n  var valueRef = useLatestRef(value);\n  var prevRef = useRef(valueRef.current);\n  var reversedValue = max - value + min;\n  var trackValue = isReversed ? reversedValue : value;\n  var trackPercent = valueToPercent(trackValue, min, max);\n  var isVertical = orientation === \"vertical\";\n  /**\n   * Let's keep a reference to the slider track and thumb\n   */\n\n  var trackRef = useRef(null);\n  var thumbRef = useRef(null);\n  var rootRef = useRef(null);\n  /**\n   * Generate unique ids for component parts\n   */\n\n  var _useIds = useIds(idProp, \"slider-thumb\", \"slider-track\"),\n    _useIds2 = _slicedToArray(_useIds, 2),\n    thumbId = _useIds2[0],\n    trackId = _useIds2[1];\n  /**\n   * Get relative value of slider from the event by tracking\n   * how far you clicked within the track to determine the value\n   *\n   * @todo - Refactor this later on to use info from pan session\n   */\n\n  var getValueFromPointer = useCallback(function (event) {\n    var _event$touches$, _event$touches;\n    if (!trackRef.current) return;\n    eventSourceRef.current = \"pointer\";\n    var trackRect = getBox(trackRef.current).borderBox;\n    var _ref = (_event$touches$ = (_event$touches = event.touches) == null ? void 0 : _event$touches[0]) != null ? _event$touches$ : event,\n      clientX = _ref.clientX,\n      clientY = _ref.clientY;\n    var diff = isVertical ? trackRect.bottom - clientY : clientX - trackRect.left;\n    var length = isVertical ? trackRect.height : trackRect.width;\n    var percent = diff / length;\n    if (isReversed) {\n      percent = 1 - percent;\n    }\n    var nextValue = percentToValue(percent, min, max);\n    if (step) {\n      nextValue = parseFloat(roundValueToStep(nextValue, min, step));\n    }\n    nextValue = clampValue(nextValue, min, max);\n    return nextValue;\n  }, [isVertical, isReversed, max, min, step]);\n  var tenSteps = (max - min) / 10;\n  var oneStep = step || (max - min) / 100;\n  var constrain = useCallback(function (value) {\n    if (!isInteractive) return;\n    value = parseFloat(roundValueToStep(value, min, oneStep));\n    value = clampValue(value, min, max);\n    setValue(value);\n  }, [oneStep, max, min, setValue, isInteractive]);\n  var actions = useMemo(function () {\n    return {\n      stepUp: function stepUp(step) {\n        if (step === void 0) {\n          step = oneStep;\n        }\n        var next = isReversed ? value - step : value + step;\n        constrain(next);\n      },\n      stepDown: function stepDown(step) {\n        if (step === void 0) {\n          step = oneStep;\n        }\n        var next = isReversed ? value + step : value - step;\n        constrain(next);\n      },\n      reset: function reset() {\n        return constrain(defaultValue || 0);\n      },\n      stepTo: function stepTo(value) {\n        return constrain(value);\n      }\n    };\n  }, [constrain, isReversed, value, oneStep, defaultValue]);\n  /**\n   * Keyboard interaction to ensure users can operate\n   * the slider using only their keyboard.\n   */\n\n  var onKeyDown = useCallback(function (event) {\n    var eventKey = normalizeEventKey(event);\n    var keyMap = {\n      ArrowRight: function ArrowRight() {\n        return actions.stepUp();\n      },\n      ArrowUp: function ArrowUp() {\n        return actions.stepUp();\n      },\n      ArrowLeft: function ArrowLeft() {\n        return actions.stepDown();\n      },\n      ArrowDown: function ArrowDown() {\n        return actions.stepDown();\n      },\n      PageUp: function PageUp() {\n        return actions.stepUp(tenSteps);\n      },\n      PageDown: function PageDown() {\n        return actions.stepDown(tenSteps);\n      },\n      Home: function Home() {\n        return constrain(min);\n      },\n      End: function End() {\n        return constrain(max);\n      }\n    };\n    var action = keyMap[eventKey];\n    if (action) {\n      event.preventDefault();\n      event.stopPropagation();\n      action(event);\n      eventSourceRef.current = \"keyboard\";\n    }\n  }, [actions, constrain, max, min, tenSteps]);\n  /**\n   * ARIA (Optional): To define a human readable representation of the value,\n   * we allow users pass aria-valuetext.\n   */\n\n  var valueText = (_getAriaValueText = getAriaValueText == null ? void 0 : getAriaValueText(value)) != null ? _getAriaValueText : ariaValueText;\n  /**\n   * Measure the dimensions of the thumb so\n   * we can center it within the track properly\n   */\n\n  var thumbBoxModel = useDimensions(thumbRef);\n  /**\n   * Compute styles for all component parts.\n   */\n\n  var _useMemo = useMemo(function () {\n      var _thumbBoxModel$border;\n      var thumbRect = (_thumbBoxModel$border = thumbBoxModel == null ? void 0 : thumbBoxModel.borderBox) != null ? _thumbBoxModel$border : {\n        width: 0,\n        height: 0\n      };\n      return getPartsStyle({\n        isReversed: isReversed,\n        orientation: orientation,\n        thumbRect: thumbRect,\n        trackPercent: trackPercent\n      });\n    }, [isReversed, orientation, thumbBoxModel == null ? void 0 : thumbBoxModel.borderBox, trackPercent]),\n    thumbStyle = _useMemo.thumbStyle,\n    rootStyle = _useMemo.rootStyle,\n    trackStyle = _useMemo.trackStyle,\n    innerTrackStyle = _useMemo.innerTrackStyle;\n  var focusThumb = useCallback(function () {\n    if (thumbRef.current && focusThumbOnChange) {\n      setTimeout(function () {\n        return focus(thumbRef.current);\n      });\n    }\n  }, [focusThumbOnChange]);\n  useUpdateEffect(function () {\n    focusThumb();\n    if (eventSourceRef.current === \"keyboard\") {\n      onChangeEnd == null ? void 0 : onChangeEnd(valueRef.current);\n    }\n  }, [value, onChangeEnd]);\n  var setValueFromPointer = function setValueFromPointer(event) {\n    var nextValue = getValueFromPointer(event);\n    if (nextValue != null && nextValue !== valueRef.current) {\n      setValue(nextValue);\n    }\n  };\n  usePanGesture(rootRef, {\n    onPanSessionStart: function onPanSessionStart(event) {\n      if (!isInteractive) return;\n      setDragging.on();\n      focusThumb();\n      setValueFromPointer(event);\n      onChangeStart == null ? void 0 : onChangeStart(valueRef.current);\n    },\n    onPanSessionEnd: function onPanSessionEnd() {\n      if (!isInteractive) return;\n      setDragging.off();\n      onChangeEnd == null ? void 0 : onChangeEnd(valueRef.current);\n      prevRef.current = valueRef.current;\n    },\n    onPan: function onPan(event) {\n      if (!isInteractive) return;\n      setValueFromPointer(event);\n    }\n  });\n  var getRootProps = useCallback(function (props, ref) {\n    if (props === void 0) {\n      props = {};\n    }\n    if (ref === void 0) {\n      ref = null;\n    }\n    return _extends({}, props, htmlProps, {\n      ref: mergeRefs(ref, rootRef),\n      tabIndex: -1,\n      \"aria-disabled\": ariaAttr(isDisabled),\n      \"data-focused\": dataAttr(isFocused),\n      style: _extends({}, props.style, rootStyle)\n    });\n  }, [htmlProps, isDisabled, isFocused, rootStyle]);\n  var getTrackProps = useCallback(function (props, ref) {\n    if (props === void 0) {\n      props = {};\n    }\n    if (ref === void 0) {\n      ref = null;\n    }\n    return _extends({}, props, {\n      ref: mergeRefs(ref, trackRef),\n      id: trackId,\n      \"data-disabled\": dataAttr(isDisabled),\n      style: _extends({}, props.style, trackStyle)\n    });\n  }, [isDisabled, trackId, trackStyle]);\n  var getInnerTrackProps = useCallback(function (props, ref) {\n    if (props === void 0) {\n      props = {};\n    }\n    if (ref === void 0) {\n      ref = null;\n    }\n    return _extends({}, props, {\n      ref: ref,\n      style: _extends({}, props.style, innerTrackStyle)\n    });\n  }, [innerTrackStyle]);\n  var getThumbProps = useCallback(function (props, ref) {\n    if (props === void 0) {\n      props = {};\n    }\n    if (ref === void 0) {\n      ref = null;\n    }\n    return _extends({}, props, {\n      ref: mergeRefs(ref, thumbRef),\n      role: \"slider\",\n      tabIndex: isInteractive ? 0 : undefined,\n      id: thumbId,\n      \"data-active\": dataAttr(isDragging),\n      \"aria-valuetext\": valueText,\n      \"aria-valuemin\": min,\n      \"aria-valuemax\": max,\n      \"aria-valuenow\": value,\n      \"aria-orientation\": orientation,\n      \"aria-disabled\": ariaAttr(isDisabled),\n      \"aria-readonly\": ariaAttr(isReadOnly),\n      \"aria-label\": ariaLabel,\n      \"aria-labelledby\": ariaLabel ? undefined : ariaLabelledBy,\n      style: _extends({}, props.style, thumbStyle),\n      onKeyDown: callAllHandlers(props.onKeyDown, onKeyDown),\n      onFocus: callAllHandlers(props.onFocus, setFocused.on),\n      onBlur: callAllHandlers(props.onBlur, setFocused.off)\n    });\n  }, [ariaLabel, ariaLabelledBy, isDisabled, isDragging, isReadOnly, isInteractive, max, min, onKeyDown, orientation, setFocused.off, setFocused.on, thumbId, thumbStyle, value, valueText]);\n  var getMarkerProps = useCallback(function (props, ref) {\n    if (props === void 0) {\n      props = {};\n    }\n    if (ref === void 0) {\n      ref = null;\n    }\n    var isInRange = !(props.value < min || props.value > max);\n    var isHighlighted = value >= props.value;\n    var markerPercent = valueToPercent(props.value, min, max);\n    var markerStyle = _extends({\n      position: \"absolute\",\n      pointerEvents: \"none\"\n    }, orient({\n      orientation: orientation,\n      vertical: {\n        bottom: isReversed ? 100 - markerPercent + \"%\" : markerPercent + \"%\"\n      },\n      horizontal: {\n        left: isReversed ? 100 - markerPercent + \"%\" : markerPercent + \"%\"\n      }\n    }));\n    return _extends({}, props, {\n      ref: ref,\n      role: \"presentation\",\n      \"aria-hidden\": true,\n      \"data-disabled\": dataAttr(isDisabled),\n      \"data-invalid\": dataAttr(!isInRange),\n      \"data-highlighted\": dataAttr(isHighlighted),\n      style: _extends({}, props.style, markerStyle)\n    });\n  }, [isDisabled, isReversed, max, min, orientation, value]);\n  var getInputProps = useCallback(function (props, ref) {\n    if (props === void 0) {\n      props = {};\n    }\n    if (ref === void 0) {\n      ref = null;\n    }\n    return _extends({}, props, {\n      ref: ref,\n      type: \"hidden\",\n      value: value,\n      name: name\n    });\n  }, [name, value]);\n  return {\n    state: {\n      value: value,\n      isFocused: isFocused,\n      isDragging: isDragging\n    },\n    actions: actions,\n    getRootProps: getRootProps,\n    getTrackProps: getTrackProps,\n    getInnerTrackProps: getInnerTrackProps,\n    getThumbProps: getThumbProps,\n    getMarkerProps: getMarkerProps,\n    getInputProps: getInputProps\n  };\n}\nfunction orient(options) {\n  var orientation = options.orientation,\n    vertical = options.vertical,\n    horizontal = options.horizontal;\n  return orientation === \"vertical\" ? vertical : horizontal;\n}\n/**\n * The browser <input type=\"range\" /> calculates\n * the default value of a slider by using mid-point\n * between the min and the max.\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/range\n */\n\nfunction getDefaultValue(min, max) {\n  return max < min ? min : min + (max - min) / 2;\n}","map":{"version":3,"names":["useBoolean","useCallbackRef","useControllableState","useDimensions","useIds","useLatestRef","usePanGesture","useUpdateEffect","mergeRefs","ariaAttr","callAllHandlers","clampValue","dataAttr","focus","getBox","normalizeEventKey","percentToValue","roundValueToStep","valueToPercent","useCallback","useMemo","useRef","getPartsStyle","getIsReversed","useSlider","props","_getAriaValueText","_props$min","min","_props$max","max","onChange","valueProp","value","defaultValue","isReversedProp","isReversed","_props$direction","direction","_props$orientation","orientation","idProp","id","isDisabled","isReadOnly","onChangeStartProp","onChangeStart","onChangeEndProp","onChangeEnd","_props$step","step","getAriaValueTextProp","getAriaValueText","ariaValueText","ariaLabel","ariaLabelledBy","name","_props$focusThumbOnCh","focusThumbOnChange","htmlProps","_objectWithoutPropertiesLoose","_useControllableState","getDefaultValue","_useControllableState2","_slicedToArray","computedValue","setValue","_useBoolean","_useBoolean2","isDragging","setDragging","_useBoolean3","_useBoolean4","isFocused","setFocused","eventSourceRef","isInteractive","valueRef","prevRef","current","reversedValue","trackValue","trackPercent","isVertical","trackRef","thumbRef","rootRef","_useIds","_useIds2","thumbId","trackId","getValueFromPointer","event","_event$touches$","_event$touches","trackRect","borderBox","_ref","touches","clientX","clientY","diff","bottom","left","length","height","width","percent","nextValue","parseFloat","tenSteps","oneStep","constrain","actions","stepUp","next","stepDown","reset","stepTo","onKeyDown","eventKey","keyMap","ArrowRight","ArrowUp","ArrowLeft","ArrowDown","PageUp","PageDown","Home","End","action","preventDefault","stopPropagation","valueText","thumbBoxModel","_useMemo","_thumbBoxModel$border","thumbRect","thumbStyle","rootStyle","trackStyle","innerTrackStyle","focusThumb","setTimeout","setValueFromPointer","onPanSessionStart","on","onPanSessionEnd","off","onPan","getRootProps","ref","_extends","tabIndex","style","getTrackProps","getInnerTrackProps","getThumbProps","role","undefined","onFocus","onBlur","getMarkerProps","isInRange","isHighlighted","markerPercent","markerStyle","position","pointerEvents","orient","vertical","horizontal","getInputProps","type","state","options"],"sources":["../../src/use-slider.ts"],"sourcesContent":["import {\n  useBoolean,\n  useCallbackRef,\n  useControllableState,\n  useDimensions,\n  useIds,\n  useLatestRef,\n  usePanGesture,\n  useUpdateEffect,\n} from \"@chakra-ui/hooks\"\nimport { EventKeyMap, mergeRefs, PropGetter } from \"@chakra-ui/react-utils\"\nimport {\n  AnyPointerEvent,\n  ariaAttr,\n  callAllHandlers,\n  clampValue,\n  dataAttr,\n  focus,\n  getBox,\n  normalizeEventKey,\n  percentToValue,\n  roundValueToStep,\n  valueToPercent,\n} from \"@chakra-ui/utils\"\nimport { CSSProperties, useCallback, useMemo, useRef } from \"react\"\nimport { getPartsStyle, getIsReversed } from \"./slider-utils\"\n\nexport interface UseSliderProps {\n  /**\n   * The minimum allowed value of the slider. Cannot be greater than max.\n   * @default 0\n   */\n  min?: number\n  /**\n   * The maximum allowed value of the slider. Cannot be less than min.\n   * @default 100\n   */\n  max?: number\n  /**\n   * The step in which increments/decrements have to be made\n   * @default 1\n   */\n  step?: number\n  /**\n   * The value of the slider in controlled mode\n   */\n  value?: number\n  /**\n   * The initial value of the slider in uncontrolled mode\n   */\n  defaultValue?: number\n  /**\n   * orientation of the slider\n   * @default \"horizontal\"\n   */\n  orientation?: \"horizontal\" | \"vertical\"\n  /**\n   * If `true`, the value will be incremented or decremented in reverse.\n   */\n  isReversed?: boolean\n  /**\n   * Function called when the user starts selecting a new value (by dragging or clicking)\n   */\n  onChangeStart?(value: number): void\n  /**\n   * Function called when the user is done selecting a new value (by dragging or clicking)\n   */\n  onChangeEnd?(value: number): void\n  /**\n   * Function called whenever the slider value changes  (by dragging or clicking)\n   */\n  onChange?(value: number): void\n  /**\n   * The base `id` to use for the slider and its components\n   */\n  id?: string\n  /**\n   * The name attribute of the hidden `input` field.\n   * This is particularly useful in forms\n   */\n  name?: string\n  /**\n   * If `true`, the slider will be disabled\n   */\n  isDisabled?: boolean\n  /**\n   * If `true`, the slider will be in `read-only` state\n   */\n  isReadOnly?: boolean\n  /**\n   * Function that returns the `aria-valuetext` for screen readers.\n   * It is mostly used to generate a more human-readable\n   * representation of the value for assistive technologies\n   */\n  getAriaValueText?(value: number): string\n  /**\n   * If `false`, the slider handle will not capture focus when value changes.\n   * @default true\n   */\n  focusThumbOnChange?: boolean\n  /**\n   * The static string to use used for `aria-valuetext`\n   */\n  \"aria-valuetext\"?: string\n  /**\n   * The static string to use used for `aria-label`\n   * if no visible label is used.\n   */\n  \"aria-label\"?: string\n  /**\n   * The static string `aria-labelledby` that points to the\n   * ID of the element that serves as label for the slider\n   */\n  \"aria-labelledby\"?: string\n  direction?: \"ltr\" | \"rtl\"\n}\n\n/**\n * React hook that implements an accessible range slider.\n *\n * It is an alternative to `<input type=\"range\" />`, and returns\n * prop getters for the component parts\n *\n * @see Docs     https://chakra-ui.com/docs/form/slider\n * @see WAI-ARIA https://www.w3.org/TR/wai-aria-practices-1.1/#slider\n */\nexport function useSlider(props: UseSliderProps) {\n  const {\n    min = 0,\n    max = 100,\n    onChange,\n    value: valueProp,\n    defaultValue,\n    isReversed: isReversedProp,\n    direction = \"ltr\",\n    orientation = \"horizontal\",\n    id: idProp,\n    isDisabled,\n    isReadOnly,\n    onChangeStart: onChangeStartProp,\n    onChangeEnd: onChangeEndProp,\n    step = 1,\n    getAriaValueText: getAriaValueTextProp,\n    \"aria-valuetext\": ariaValueText,\n    \"aria-label\": ariaLabel,\n    \"aria-labelledby\": ariaLabelledBy,\n    name,\n    focusThumbOnChange = true,\n    ...htmlProps\n  } = props\n\n  const onChangeStart = useCallbackRef(onChangeStartProp)\n  const onChangeEnd = useCallbackRef(onChangeEndProp)\n  const getAriaValueText = useCallbackRef(getAriaValueTextProp)\n\n  const isReversed = getIsReversed({\n    isReversed: isReversedProp,\n    direction,\n    orientation,\n  })\n\n  /**\n   * Enable the slider handle controlled and uncontrolled scenarios\n   */\n  const [computedValue, setValue] = useControllableState({\n    value: valueProp,\n    defaultValue: defaultValue ?? getDefaultValue(min, max),\n    onChange,\n  })\n\n  const [isDragging, setDragging] = useBoolean()\n\n  const [isFocused, setFocused] = useBoolean()\n  const eventSourceRef = useRef<\"pointer\" | \"keyboard\" | null>(null)\n\n  const isInteractive = !(isDisabled || isReadOnly)\n\n  /**\n   * Constrain the value because it can't be less than min\n   * or greater than max\n   */\n  const value = clampValue(computedValue, min, max)\n  const valueRef = useLatestRef(value)\n\n  const prevRef = useRef(valueRef.current)\n\n  const reversedValue = max - value + min\n  const trackValue = isReversed ? reversedValue : value\n  const trackPercent = valueToPercent(trackValue, min, max)\n\n  const isVertical = orientation === \"vertical\"\n\n  /**\n   * Let's keep a reference to the slider track and thumb\n   */\n  const trackRef = useRef<any>(null)\n  const thumbRef = useRef<any>(null)\n  const rootRef = useRef<any>(null)\n\n  /**\n   * Generate unique ids for component parts\n   */\n  const [thumbId, trackId] = useIds(idProp, `slider-thumb`, `slider-track`)\n\n  /**\n   * Get relative value of slider from the event by tracking\n   * how far you clicked within the track to determine the value\n   *\n   * @todo - Refactor this later on to use info from pan session\n   */\n\n  const getValueFromPointer = useCallback(\n    (event) => {\n      if (!trackRef.current) return\n      eventSourceRef.current = \"pointer\"\n      const trackRect = getBox(trackRef.current).borderBox\n      const { clientX, clientY } = event.touches?.[0] ?? event\n\n      const diff = isVertical\n        ? trackRect.bottom - clientY\n        : clientX - trackRect.left\n\n      const length = isVertical ? trackRect.height : trackRect.width\n      let percent = diff / length\n\n      if (isReversed) {\n        percent = 1 - percent\n      }\n\n      let nextValue = percentToValue(percent, min, max)\n\n      if (step) {\n        nextValue = parseFloat(roundValueToStep(nextValue, min, step))\n      }\n\n      nextValue = clampValue(nextValue, min, max)\n\n      return nextValue\n    },\n    [isVertical, isReversed, max, min, step],\n  )\n\n  const tenSteps = (max - min) / 10\n  const oneStep = step || (max - min) / 100\n\n  const constrain = useCallback(\n    (value: number) => {\n      if (!isInteractive) return\n      value = parseFloat(roundValueToStep(value, min, oneStep))\n      value = clampValue(value, min, max)\n      setValue(value)\n    },\n    [oneStep, max, min, setValue, isInteractive],\n  )\n\n  const actions = useMemo(\n    () => ({\n      stepUp: (step = oneStep) => {\n        const next = isReversed ? value - step : value + step\n        constrain(next)\n      },\n      stepDown: (step = oneStep) => {\n        const next = isReversed ? value + step : value - step\n        constrain(next)\n      },\n      reset: () => constrain(defaultValue || 0),\n      stepTo: (value: number) => constrain(value),\n    }),\n    [constrain, isReversed, value, oneStep, defaultValue],\n  )\n\n  /**\n   * Keyboard interaction to ensure users can operate\n   * the slider using only their keyboard.\n   */\n  const onKeyDown = useCallback(\n    (event: React.KeyboardEvent) => {\n      const eventKey = normalizeEventKey(event)\n      const keyMap: EventKeyMap = {\n        ArrowRight: () => actions.stepUp(),\n        ArrowUp: () => actions.stepUp(),\n        ArrowLeft: () => actions.stepDown(),\n        ArrowDown: () => actions.stepDown(),\n        PageUp: () => actions.stepUp(tenSteps),\n        PageDown: () => actions.stepDown(tenSteps),\n        Home: () => constrain(min),\n        End: () => constrain(max),\n      }\n\n      const action = keyMap[eventKey]\n\n      if (action) {\n        event.preventDefault()\n        event.stopPropagation()\n        action(event)\n        eventSourceRef.current = \"keyboard\"\n      }\n    },\n    [actions, constrain, max, min, tenSteps],\n  )\n\n  /**\n   * ARIA (Optional): To define a human readable representation of the value,\n   * we allow users pass aria-valuetext.\n   */\n  const valueText = getAriaValueText?.(value) ?? ariaValueText\n\n  /**\n   * Measure the dimensions of the thumb so\n   * we can center it within the track properly\n   */\n  const thumbBoxModel = useDimensions(thumbRef)\n\n  /**\n   * Compute styles for all component parts.\n   */\n  const { thumbStyle, rootStyle, trackStyle, innerTrackStyle } = useMemo(() => {\n    const thumbRect = thumbBoxModel?.borderBox ?? { width: 0, height: 0 }\n    return getPartsStyle({\n      isReversed,\n      orientation,\n      thumbRect,\n      trackPercent,\n    })\n  }, [isReversed, orientation, thumbBoxModel?.borderBox, trackPercent])\n\n  const focusThumb = useCallback(() => {\n    if (thumbRef.current && focusThumbOnChange) {\n      setTimeout(() => focus(thumbRef.current))\n    }\n  }, [focusThumbOnChange])\n\n  useUpdateEffect(() => {\n    focusThumb()\n    if (eventSourceRef.current === \"keyboard\") {\n      onChangeEnd?.(valueRef.current)\n    }\n  }, [value, onChangeEnd])\n\n  const setValueFromPointer = (event: AnyPointerEvent) => {\n    const nextValue = getValueFromPointer(event)\n    if (nextValue != null && nextValue !== valueRef.current) {\n      setValue(nextValue)\n    }\n  }\n\n  usePanGesture(rootRef, {\n    onPanSessionStart(event) {\n      if (!isInteractive) return\n      setDragging.on()\n      focusThumb()\n      setValueFromPointer(event)\n      onChangeStart?.(valueRef.current)\n    },\n    onPanSessionEnd() {\n      if (!isInteractive) return\n      setDragging.off()\n      onChangeEnd?.(valueRef.current)\n      prevRef.current = valueRef.current\n    },\n    onPan(event) {\n      if (!isInteractive) return\n      setValueFromPointer(event)\n    },\n  })\n\n  const getRootProps: PropGetter = useCallback(\n    (props = {}, ref = null) => ({\n      ...props,\n      ...htmlProps,\n      ref: mergeRefs(ref, rootRef),\n      tabIndex: -1,\n      \"aria-disabled\": ariaAttr(isDisabled),\n      \"data-focused\": dataAttr(isFocused),\n      style: {\n        ...props.style,\n        ...rootStyle,\n      },\n    }),\n    [htmlProps, isDisabled, isFocused, rootStyle],\n  )\n\n  const getTrackProps: PropGetter = useCallback(\n    (props = {}, ref = null) => ({\n      ...props,\n      ref: mergeRefs(ref, trackRef),\n      id: trackId,\n      \"data-disabled\": dataAttr(isDisabled),\n      style: {\n        ...props.style,\n        ...trackStyle,\n      },\n    }),\n    [isDisabled, trackId, trackStyle],\n  )\n\n  const getInnerTrackProps: PropGetter = useCallback(\n    (props = {}, ref = null) => ({\n      ...props,\n      ref,\n      style: {\n        ...props.style,\n        ...innerTrackStyle,\n      },\n    }),\n    [innerTrackStyle],\n  )\n\n  const getThumbProps: PropGetter = useCallback(\n    (props = {}, ref = null) => ({\n      ...props,\n      ref: mergeRefs(ref, thumbRef),\n      role: \"slider\",\n      tabIndex: isInteractive ? 0 : undefined,\n      id: thumbId,\n      \"data-active\": dataAttr(isDragging),\n      \"aria-valuetext\": valueText,\n      \"aria-valuemin\": min,\n      \"aria-valuemax\": max,\n      \"aria-valuenow\": value,\n      \"aria-orientation\": orientation,\n      \"aria-disabled\": ariaAttr(isDisabled),\n      \"aria-readonly\": ariaAttr(isReadOnly),\n      \"aria-label\": ariaLabel,\n      \"aria-labelledby\": ariaLabel ? undefined : ariaLabelledBy,\n      style: {\n        ...props.style,\n        ...thumbStyle,\n      },\n      onKeyDown: callAllHandlers(props.onKeyDown, onKeyDown),\n      onFocus: callAllHandlers(props.onFocus, setFocused.on),\n      onBlur: callAllHandlers(props.onBlur, setFocused.off),\n    }),\n    [\n      ariaLabel,\n      ariaLabelledBy,\n      isDisabled,\n      isDragging,\n      isReadOnly,\n      isInteractive,\n      max,\n      min,\n      onKeyDown,\n      orientation,\n      setFocused.off,\n      setFocused.on,\n      thumbId,\n      thumbStyle,\n      value,\n      valueText,\n    ],\n  )\n\n  const getMarkerProps: PropGetter<any, { value?: any }> = useCallback(\n    (props = {}, ref = null) => {\n      const isInRange = !(props.value < min || props.value > max)\n      const isHighlighted = value >= props.value\n      const markerPercent = valueToPercent(props.value, min, max)\n\n      const markerStyle: React.CSSProperties = {\n        position: \"absolute\",\n        pointerEvents: \"none\",\n        ...orient({\n          orientation,\n          vertical: {\n            bottom: isReversed\n              ? `${100 - markerPercent}%`\n              : `${markerPercent}%`,\n          },\n          horizontal: {\n            left: isReversed ? `${100 - markerPercent}%` : `${markerPercent}%`,\n          },\n        }),\n      }\n\n      return {\n        ...props,\n        ref,\n        role: \"presentation\",\n        \"aria-hidden\": true,\n        \"data-disabled\": dataAttr(isDisabled),\n        \"data-invalid\": dataAttr(!isInRange),\n        \"data-highlighted\": dataAttr(isHighlighted),\n        style: {\n          ...props.style,\n          ...markerStyle,\n        },\n      }\n    },\n    [isDisabled, isReversed, max, min, orientation, value],\n  )\n\n  const getInputProps: PropGetter<HTMLInputElement> = useCallback(\n    (props = {}, ref = null) => ({\n      ...props,\n      ref,\n      type: \"hidden\",\n      value,\n      name,\n    }),\n    [name, value],\n  )\n\n  return {\n    state: {\n      value,\n      isFocused,\n      isDragging,\n    },\n    actions,\n    getRootProps,\n    getTrackProps,\n    getInnerTrackProps,\n    getThumbProps,\n    getMarkerProps,\n    getInputProps,\n  }\n}\n\nexport type UseSliderReturn = ReturnType<typeof useSlider>\n\nfunction orient(options: {\n  orientation: UseSliderProps[\"orientation\"]\n  vertical: CSSProperties\n  horizontal: CSSProperties\n}) {\n  const { orientation, vertical, horizontal } = options\n  return orientation === \"vertical\" ? vertical : horizontal\n}\n\n/**\n * The browser <input type=\"range\" /> calculates\n * the default value of a slider by using mid-point\n * between the min and the max.\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/range\n */\nfunction getDefaultValue(min: number, max: number) {\n  return max < min ? min : min + (max - min) / 2\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}