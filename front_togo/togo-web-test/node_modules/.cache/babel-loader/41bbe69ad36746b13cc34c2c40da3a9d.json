{"ast":null,"code":"import _regeneratorRuntime from \"/home/system/togo-web-test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/home/system/togo-web-test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"/home/system/togo-web-test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/system/togo-web-test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\n\n(function () {\n  var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;\n  enterModule && enterModule(module);\n})();\n\nvar __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {\n  return a;\n};\n/**\n * A utility for communications between an iframe and its parent, used by the Superset embedded SDK.\n * This builds useful patterns on top of the basic functionality offered by MessageChannel.\n *\n * Both windows instantiate a Switchboard, passing in their MessagePorts.\n * Calling methods on the switchboard causes messages to be sent through the channel.\n */\n\n\nexport var Switchboard = /*#__PURE__*/function () {\n  // used to make unique ids\n  function Switchboard(_ref) {\n    var _this = this;\n\n    var port = _ref.port,\n        _ref$name = _ref.name,\n        name = _ref$name === void 0 ? 'switchboard' : _ref$name,\n        _ref$debug = _ref.debug,\n        debug = _ref$debug === void 0 ? false : _ref$debug;\n\n    _classCallCheck(this, Switchboard);\n\n    this.port = void 0;\n    this.name = void 0;\n    this.methods = {};\n    this.incrementor = 1;\n    this.debugMode = void 0;\n    this.port = port;\n    this.name = name;\n    this.debugMode = debug;\n    port.addEventListener('message', /*#__PURE__*/function () {\n      var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(event) {\n        var message, method, args, executor;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _this.log('message received', event);\n\n                message = event.data;\n\n                if (!isGet(message)) {\n                  _context.next = 10;\n                  break;\n                }\n\n                _context.t0 = _this.port;\n                _context.next = 6;\n                return _this.getMethodResult(message);\n\n              case 6:\n                _context.t1 = _context.sent;\n\n                _context.t0.postMessage.call(_context.t0, _context.t1);\n\n                _context.next = 11;\n                break;\n\n              case 10:\n                if (isEmit(message)) {\n                  method = message.method, args = message.args; // Find the method and call it, but no result necessary.\n                  // Should this multicast to a set of listeners?\n                  // Maybe, but that requires writing a bunch more code\n                  // and I haven't found a need for it yet.\n\n                  executor = _this.methods[method];\n\n                  if (executor) {\n                    executor(args);\n                  }\n                }\n\n              case 11:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n\n      return function (_x) {\n        return _ref2.apply(this, arguments);\n      };\n    }());\n  }\n\n  _createClass(Switchboard, [{\n    key: \"getMethodResult\",\n    value: function () {\n      var _getMethodResult = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(_ref3) {\n        var messageId, method, args, executor, result;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                messageId = _ref3.messageId, method = _ref3.method, args = _ref3.args;\n                executor = this.methods[method];\n\n                if (!(executor == null)) {\n                  _context2.next = 4;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", {\n                  switchboardAction: Actions.ERROR,\n                  messageId: messageId,\n                  error: \"[\".concat(this.name, \"] Method \\\"\").concat(method, \"\\\" is not defined\")\n                });\n\n              case 4:\n                _context2.prev = 4;\n                _context2.next = 7;\n                return executor(args);\n\n              case 7:\n                result = _context2.sent;\n                return _context2.abrupt(\"return\", {\n                  switchboardAction: Actions.REPLY,\n                  messageId: messageId,\n                  result: result\n                });\n\n              case 11:\n                _context2.prev = 11;\n                _context2.t0 = _context2[\"catch\"](4);\n                this.logError(_context2.t0);\n                return _context2.abrupt(\"return\", {\n                  switchboardAction: Actions.ERROR,\n                  messageId: messageId,\n                  error: \"[\".concat(this.name, \"] Method \\\"\").concat(method, \"\\\" threw an error\")\n                });\n\n              case 15:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this, [[4, 11]]);\n      }));\n\n      function getMethodResult(_x2) {\n        return _getMethodResult.apply(this, arguments);\n      }\n\n      return getMethodResult;\n    }()\n    /**\n     * Defines a method that can be \"called\" from the other side by sending an event.\n     */\n\n  }, {\n    key: \"defineMethod\",\n    value: function defineMethod(methodName, executor) {\n      this.methods[methodName] = executor;\n    }\n    /**\n     * Calls a method registered on the other side, and returns the result.\n     *\n     * How this is accomplished:\n     * This switchboard sends a \"get\" message over the channel describing which method to call with which arguments.\n     * The other side's switchboard finds a method with that name, and calls it with the arguments.\n     * It then packages up the returned value into a \"reply\" message, sending it back to us across the channel.\n     * This switchboard has attached a listener on the channel, which will resolve with the result when a reply is detected.\n     *\n     * Instead of an arguments list, arguments are supplied as a map.\n     *\n     * @param method the name of the method to call\n     * @param args arguments that will be supplied. Must be serializable, no functions or other nonense.\n     * @returns whatever is returned from the method\n     */\n\n  }, {\n    key: \"get\",\n    value: function get(method) {\n      var _this2 = this;\n\n      var args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n      return new Promise(function (resolve, reject) {\n        // In order to \"call a method\" on the other side of the port,\n        // we will send a message with a unique id\n        var messageId = _this2.getNewMessageId(); // attach a new listener to our port, and remove it when we get a response\n\n\n        var listener = function listener(event) {\n          var message = event.data;\n          if (message.messageId !== messageId) return;\n\n          _this2.port.removeEventListener('message', listener);\n\n          if (isReply(message)) {\n            resolve(message.result);\n          } else {\n            var errStr = isError(message) ? message.error : 'Unexpected response message';\n            reject(new Error(errStr));\n          }\n        };\n\n        _this2.port.addEventListener('message', listener);\n\n        _this2.port.start();\n\n        var message = {\n          switchboardAction: Actions.GET,\n          method: method,\n          messageId: messageId,\n          args: args\n        };\n\n        _this2.port.postMessage(message);\n      });\n    }\n    /**\n     * Emit calls a method on the other side just like get does.\n     * But emit doesn't wait for a response, it just sends and forgets.\n     *\n     * @param method\n     * @param args\n     */\n\n  }, {\n    key: \"emit\",\n    value: function emit(method) {\n      var args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n      var message = {\n        switchboardAction: Actions.EMIT,\n        method: method,\n        args: args\n      };\n      this.port.postMessage(message);\n    }\n  }, {\n    key: \"start\",\n    value: function start() {\n      this.port.start();\n    }\n  }, {\n    key: \"log\",\n    value: function log() {\n      if (this.debugMode) {\n        var _console;\n\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n\n        (_console = console).debug.apply(_console, [\"[\".concat(this.name, \"]\")].concat(args));\n      }\n    }\n  }, {\n    key: \"logError\",\n    value: function logError() {\n      var _console2;\n\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      (_console2 = console).error.apply(_console2, [\"[\".concat(this.name, \"]\")].concat(args));\n    }\n  }, {\n    key: \"getNewMessageId\",\n    value: function getNewMessageId() {\n      // eslint-disable-next-line no-plusplus\n      return \"m_\".concat(this.name, \"_\").concat(this.incrementor++);\n    } // @ts-ignore\n\n  }, {\n    key: \"__reactstandin__regenerateByEval\",\n    value: function __reactstandin__regenerateByEval(key, code) {\n      // @ts-ignore\n      this[key] = eval(code);\n    }\n  }]);\n\n  return Switchboard;\n}(); // Each message we send on the channel specifies an action we want the other side to cooperate with.\n\nvar Actions; // helper types/functions for making sure wires don't get crossed\n\n(function (Actions) {\n  Actions[\"GET\"] = \"get\";\n  Actions[\"REPLY\"] = \"reply\";\n  Actions[\"EMIT\"] = \"emit\";\n  Actions[\"ERROR\"] = \"error\";\n})(Actions || (Actions = {}));\n\nfunction isGet(message) {\n  return message.switchboardAction === Actions.GET;\n}\n\nfunction isReply(message) {\n  return message.switchboardAction === Actions.REPLY;\n}\n\nfunction isEmit(message) {\n  return message.switchboardAction === Actions.EMIT;\n}\n\nfunction isError(message) {\n  return message.switchboardAction === Actions.ERROR;\n}\n\n;\n\n(function () {\n  var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;\n\n  if (!reactHotLoader) {\n    return;\n  }\n\n  reactHotLoader.register(Switchboard, \"Switchboard\", \"/Users/aaron/work/superset/superset-frontend/packages/superset-ui-switchboard/src/switchboard.ts\");\n  reactHotLoader.register(isGet, \"isGet\", \"/Users/aaron/work/superset/superset-frontend/packages/superset-ui-switchboard/src/switchboard.ts\");\n  reactHotLoader.register(isReply, \"isReply\", \"/Users/aaron/work/superset/superset-frontend/packages/superset-ui-switchboard/src/switchboard.ts\");\n  reactHotLoader.register(isEmit, \"isEmit\", \"/Users/aaron/work/superset/superset-frontend/packages/superset-ui-switchboard/src/switchboard.ts\");\n  reactHotLoader.register(isError, \"isError\", \"/Users/aaron/work/superset/superset-frontend/packages/superset-ui-switchboard/src/switchboard.ts\");\n})();\n\n;\n\n(function () {\n  var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;\n  leaveModule && leaveModule(module);\n})();","map":{"version":3,"sources":["/home/system/togo-web-test/node_modules/@superset-ui/switchboard/esm/switchboard.js"],"names":["enterModule","reactHotLoaderGlobal","undefined","module","__signature__","default","signature","a","Switchboard","port","name","debug","methods","incrementor","debugMode","addEventListener","event","log","message","data","isGet","getMethodResult","postMessage","isEmit","method","args","executor","messageId","switchboardAction","Actions","ERROR","error","result","REPLY","logError","methodName","Promise","resolve","reject","getNewMessageId","listener","removeEventListener","isReply","errStr","isError","Error","start","GET","EMIT","console","key","code","eval","reactHotLoader","register","leaveModule"],"mappings":"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","sourcesContent":["(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;};\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * A utility for communications between an iframe and its parent, used by the Superset embedded SDK.\n * This builds useful patterns on top of the basic functionality offered by MessageChannel.\n *\n * Both windows instantiate a Switchboard, passing in their MessagePorts.\n * Calling methods on the switchboard causes messages to be sent through the channel.\n */\nexport class Switchboard {\n\n\n\n\n\n\n  // used to make unique ids\n\n\n\n\n  constructor({ port, name = 'switchboard', debug = false }) {this.port = void 0;this.name = void 0;this.methods = {};this.incrementor = 1;this.debugMode = void 0;\n    this.port = port;\n    this.name = name;\n    this.debugMode = debug;\n\n    port.addEventListener('message', async (event) => {\n      this.log('message received', event);\n      const message = event.data;\n      if (isGet(message)) {\n        // find the method, call it, and reply with the result\n        this.port.postMessage(await this.getMethodResult(message));\n      } else if (isEmit(message)) {\n        const { method, args } = message;\n        // Find the method and call it, but no result necessary.\n        // Should this multicast to a set of listeners?\n        // Maybe, but that requires writing a bunch more code\n        // and I haven't found a need for it yet.\n        const executor = this.methods[method];\n        if (executor) {\n          executor(args);\n        }\n      }\n    });\n  }\n\n  async getMethodResult({\n    messageId,\n    method,\n    args })\n  {\n    const executor = this.methods[method];\n    if (executor == null) {\n      return {\n        switchboardAction: Actions.ERROR,\n        messageId,\n        error: `[${this.name}] Method \"${method}\" is not defined` };\n\n    }\n    try {\n      const result = await executor(args);\n      return {\n        switchboardAction: Actions.REPLY,\n        messageId,\n        result };\n\n    } catch (err) {\n      this.logError(err);\n      return {\n        switchboardAction: Actions.ERROR,\n        messageId,\n        error: `[${this.name}] Method \"${method}\" threw an error` };\n\n    }\n  }\n\n  /**\n   * Defines a method that can be \"called\" from the other side by sending an event.\n   */\n  defineMethod(methodName, executor) {\n    this.methods[methodName] = executor;\n  }\n\n  /**\n   * Calls a method registered on the other side, and returns the result.\n   *\n   * How this is accomplished:\n   * This switchboard sends a \"get\" message over the channel describing which method to call with which arguments.\n   * The other side's switchboard finds a method with that name, and calls it with the arguments.\n   * It then packages up the returned value into a \"reply\" message, sending it back to us across the channel.\n   * This switchboard has attached a listener on the channel, which will resolve with the result when a reply is detected.\n   *\n   * Instead of an arguments list, arguments are supplied as a map.\n   *\n   * @param method the name of the method to call\n   * @param args arguments that will be supplied. Must be serializable, no functions or other nonense.\n   * @returns whatever is returned from the method\n   */\n  get(method, args = undefined) {\n    return new Promise((resolve, reject) => {\n      // In order to \"call a method\" on the other side of the port,\n      // we will send a message with a unique id\n      const messageId = this.getNewMessageId();\n      // attach a new listener to our port, and remove it when we get a response\n      const listener = (event) => {\n        const message = event.data;\n        if (message.messageId !== messageId) return;\n        this.port.removeEventListener('message', listener);\n        if (isReply(message)) {\n          resolve(message.result);\n        } else {\n          const errStr = isError(message) ?\n          message.error :\n          'Unexpected response message';\n          reject(new Error(errStr));\n        }\n      };\n      this.port.addEventListener('message', listener);\n      this.port.start();\n      const message = {\n        switchboardAction: Actions.GET,\n        method,\n        messageId,\n        args };\n\n      this.port.postMessage(message);\n    });\n  }\n\n  /**\n   * Emit calls a method on the other side just like get does.\n   * But emit doesn't wait for a response, it just sends and forgets.\n   *\n   * @param method\n   * @param args\n   */\n  emit(method, args = undefined) {\n    const message = {\n      switchboardAction: Actions.EMIT,\n      method,\n      args };\n\n    this.port.postMessage(message);\n  }\n\n  start() {\n    this.port.start();\n  }\n\n  log(...args) {\n    if (this.debugMode) {\n      console.debug(`[${this.name}]`, ...args);\n    }\n  }\n\n  logError(...args) {\n    console.error(`[${this.name}]`, ...args);\n  }\n\n  getNewMessageId() {\n    // eslint-disable-next-line no-plusplus\n    return `m_${this.name}_${this.incrementor++}`;\n  } // @ts-ignore\n  __reactstandin__regenerateByEval(key, code) {// @ts-ignore\n    this[key] = eval(code);}}\n\n\n// Each message we send on the channel specifies an action we want the other side to cooperate with.\nvar Actions;\n\n\n\n\n\n\n// helper types/functions for making sure wires don't get crossed\n(function (Actions) {Actions[\"GET\"] = \"get\";Actions[\"REPLY\"] = \"reply\";Actions[\"EMIT\"] = \"emit\";Actions[\"ERROR\"] = \"error\";})(Actions || (Actions = {}));\n\n\n\n\n\n\n\n\n\n\n\nfunction isGet(message) {\n  return message.switchboardAction === Actions.GET;\n}\n\n\n\n\n\n\n\nfunction isReply(message) {\n  return message.switchboardAction === Actions.REPLY;\n}\n\n\n\n\n\n\n\nfunction isEmit(message) {\n  return message.switchboardAction === Actions.EMIT;\n}\n\n\n\n\n\n\n\nfunction isError(message) {\n  return message.switchboardAction === Actions.ERROR;\n};(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(Switchboard, \"Switchboard\", \"/Users/aaron/work/superset/superset-frontend/packages/superset-ui-switchboard/src/switchboard.ts\");reactHotLoader.register(isGet, \"isGet\", \"/Users/aaron/work/superset/superset-frontend/packages/superset-ui-switchboard/src/switchboard.ts\");reactHotLoader.register(isReply, \"isReply\", \"/Users/aaron/work/superset/superset-frontend/packages/superset-ui-switchboard/src/switchboard.ts\");reactHotLoader.register(isEmit, \"isEmit\", \"/Users/aaron/work/superset/superset-frontend/packages/superset-ui-switchboard/src/switchboard.ts\");reactHotLoader.register(isError, \"isError\", \"/Users/aaron/work/superset/superset-frontend/packages/superset-ui-switchboard/src/switchboard.ts\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();"]},"metadata":{},"sourceType":"module"}