{"ast":null,"code":"import _slicedToArray from \"/home/system/togo-web-test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _classCallCheck from \"/home/system/togo-web-test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/system/togo-web-test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\n/**\n * Used to define the anatomy/parts of a component in a way that provides\n * a consistent API for `className`, css selector and `theming`.\n */\nexport var Anatomy = /*#__PURE__*/function () {\n  function Anatomy(name) {\n    var _this2 = this;\n    _classCallCheck(this, Anatomy);\n    var _this = this;\n    this.name = name;\n    _defineProperty(this, \"map\", {});\n    _defineProperty(this, \"called\", false);\n    _defineProperty(this, \"assert\", function () {\n      if (!_this2.called) {\n        _this2.called = true;\n        return;\n      }\n      throw new Error(\"[anatomy] .part(...) should only be called once. Did you mean to use .extend(...) ?\");\n    });\n    _defineProperty(this, \"parts\", function () {\n      _this.assert();\n      for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {\n        values[_key] = arguments[_key];\n      }\n      for (var _i = 0, _values = values; _i < _values.length; _i++) {\n        var part = _values[_i];\n        ;\n        _this.map[part] = _this.toPart(part);\n      }\n      return _this;\n    });\n    _defineProperty(this, \"extend\", function () {\n      for (var _len2 = arguments.length, parts = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        parts[_key2] = arguments[_key2];\n      }\n      for (var _i2 = 0, _parts = parts; _i2 < _parts.length; _i2++) {\n        var part = _parts[_i2];\n        if (part in _this.map) continue;\n        _this.map[part] = _this.toPart(part);\n      }\n      return _this;\n    });\n    _defineProperty(this, \"toPart\", function (part) {\n      var el = [\"container\", \"root\"].includes(part != null ? part : \"\") ? [_this2.name] : [_this2.name, part];\n      var attr = el.filter(Boolean).join(\"__\");\n      var className = \"chakra-\" + attr;\n      var partObj = {\n        className: className,\n        selector: \".\" + className,\n        toString: function toString() {\n          return part;\n        }\n      };\n      return partObj;\n    });\n    _defineProperty(this, \"__type\", {});\n  }\n  /**\n   * Prevents user from calling `.parts` multiple times.\n   * It should only be called once.\n   */\n\n  /**\n   * Get all selectors for the component anatomy\n   */\n  _createClass(Anatomy, [{\n    key: \"selectors\",\n    get: function get() {\n      var value = Object.fromEntries(Object.entries(this.map).map(function (_ref) {\n        var _ref3 = _slicedToArray(_ref, 2),\n          key = _ref3[0],\n          part = _ref3[1];\n        return [key, part.selector];\n      }));\n      return value;\n    }\n    /**\n     * Get all classNames for the component anatomy\n     */\n  }, {\n    key: \"classNames\",\n    get: function get() {\n      var value = Object.fromEntries(Object.entries(this.map).map(function (_ref2) {\n        var _ref4 = _slicedToArray(_ref2, 2),\n          key = _ref4[0],\n          part = _ref4[1];\n        return [key, part.className];\n      }));\n      return value;\n    }\n    /**\n     * Get all parts as array of string\n     */\n  }, {\n    key: \"keys\",\n    get: function get() {\n      return Object.keys(this.map);\n    }\n    /**\n     * Creates the part object for the given part\n     */\n  }]);\n  return Anatomy;\n}();\nexport function anatomy(name) {\n  return new Anatomy(name);\n}","map":{"version":3,"names":["Anatomy","name","_this2","_classCallCheck","_this","_defineProperty","called","Error","assert","_len","arguments","length","values","Array","_key","_i","_values","part","map","toPart","_len2","parts","_key2","_i2","_parts","el","includes","attr","filter","Boolean","join","className","partObj","selector","toString","_createClass","key","get","value","Object","fromEntries","entries","_ref","_ref3","_slicedToArray","_ref2","_ref4","keys","anatomy"],"sources":["../../src/anatomy.ts"],"sourcesContent":["/**\n * Used to define the anatomy/parts of a component in a way that provides\n * a consistent API for `className`, css selector and `theming`.\n */\nexport class Anatomy<T extends string = string> {\n  private map: Record<T, Part> = {} as Record<T, Part>\n  private called = false\n\n  constructor(private name: string) {}\n\n  /**\n   * Prevents user from calling `.parts` multiple times.\n   * It should only be called once.\n   */\n  private assert = () => {\n    if (!this.called) {\n      this.called = true\n      return\n    }\n\n    throw new Error(\n      \"[anatomy] .part(...) should only be called once. Did you mean to use .extend(...) ?\",\n    )\n  }\n\n  /**\n   * Add the core parts of the components\n   */\n  public parts = <V extends string>(...values: V[]) => {\n    this.assert()\n    for (const part of values) {\n      ;(this.map as any)[part] = this.toPart(part)\n    }\n    return (this as unknown) as Omit<Anatomy<V>, \"parts\">\n  }\n\n  /**\n   * Extend the component anatomy to includes new parts\n   */\n  public extend = <U extends string>(...parts: U[]) => {\n    for (const part of parts) {\n      if (part in this.map) continue\n      ;(this.map as any)[part] = this.toPart(part)\n    }\n    return (this as unknown) as Omit<Anatomy<T | U>, \"parts\">\n  }\n\n  /**\n   * Get all selectors for the component anatomy\n   */\n  get selectors() {\n    const value = Object.fromEntries(\n      Object.entries(this.map).map(([key, part]) => [\n        key,\n        (part as any).selector,\n      ]),\n    )\n    return value as Record<T, string>\n  }\n\n  /**\n   * Get all classNames for the component anatomy\n   */\n  get classNames() {\n    const value = Object.fromEntries(\n      Object.entries(this.map).map(([key, part]) => [\n        key,\n        (part as any).className,\n      ]),\n    )\n    return value as Record<T, string>\n  }\n\n  /**\n   * Get all parts as array of string\n   */\n  get keys() {\n    return Object.keys(this.map) as T[]\n  }\n\n  /**\n   * Creates the part object for the given part\n   */\n  toPart = (part: string) => {\n    const el = [\"container\", \"root\"].includes(part ?? \"\")\n      ? [this.name]\n      : [this.name, part]\n    const attr = el.filter(Boolean).join(\"__\")\n    const className = `chakra-${attr}`\n\n    const partObj = {\n      className,\n      selector: `.${className}`,\n      toString: () => part,\n    }\n\n    return partObj as typeof partObj & string\n  }\n\n  /**\n   * Used to get the derived type of the anatomy\n   */\n  __type = {} as T\n}\n\ntype Part = {\n  className: string\n  selector: string\n  toString: () => string\n}\n\nexport function anatomy(name: string) {\n  return new Anatomy(name)\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}