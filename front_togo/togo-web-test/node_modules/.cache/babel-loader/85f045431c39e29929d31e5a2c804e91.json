{"ast":null,"code":"import { createFactory as t, Component as r } from \"react\";\nimport { polyfill as n } from \"react-lifecycles-compat\";\n\nvar e = function e(t) {\n  return \"string\" == typeof t ? t : t ? t.displayName || t.name || \"Component\" : void 0;\n},\n    o = function o(t, r) {\n  return function (n) {\n    return n[t] = r, n;\n  };\n},\n    u = function u(t) {\n  return o(\"displayName\", t);\n},\n    p = Object.prototype.hasOwnProperty;\n\nfunction c(t, r) {\n  return t === r ? 0 !== t || 0 !== r || 1 / t == 1 / r : t != t && r != r;\n}\n\nfunction i(t, r) {\n  if (c(t, r)) return !0;\n  if (\"object\" != typeof t || null === t || \"object\" != typeof r || null === r) return !1;\n  var n = Object.keys(t),\n      e = Object.keys(r);\n  if (n.length !== e.length) return !1;\n\n  for (var o = 0; o < n.length; o++) {\n    if (!p.call(r, n[o]) || !c(t[n[o]], r[n[o]])) return !1;\n  }\n\n  return !0;\n}\n\nfunction a() {\n  return a = Object.assign || function (t) {\n    for (var r = 1; r < arguments.length; r++) {\n      var n = arguments[r];\n\n      for (var e in n) {\n        Object.prototype.hasOwnProperty.call(n, e) && (t[e] = n[e]);\n      }\n    }\n\n    return t;\n  }, a.apply(this, arguments);\n}\n\nfunction f(t, r) {\n  t.prototype = Object.create(r.prototype), t.prototype.constructor = t, s(t, r);\n}\n\nfunction s(t, r) {\n  return s = Object.setPrototypeOf || function (t, r) {\n    return t.__proto__ = r, t;\n  }, s(t, r);\n}\n\nvar l = function l(t, r) {\n  return r + \"(\" + e(t) + \")\";\n},\n    v = function v(n) {\n  return function (e) {\n    var o = t(e),\n        p = function (t) {\n      function r() {\n        return t.apply(this, arguments) || this;\n      }\n\n      f(r, t);\n      var e = r.prototype;\n      return e.shouldComponentUpdate = function (t) {\n        return n(this.props, t);\n      }, e.render = function () {\n        return o(this.props);\n      }, r;\n    }(r);\n\n    return \"production\" !== process.env.NODE_ENV ? u(l(e, \"shouldUpdate\"))(p) : p;\n  };\n},\n    y = function y(t) {\n  var r = v(function (t, r) {\n    return !i(t, r);\n  });\n  return \"production\" !== process.env.NODE_ENV ? u(l(t, \"pure\"))(r(t)) : r(t);\n},\n    h = function h() {\n  for (var t = arguments.length, r = new Array(t), n = 0; n < t; n++) {\n    r[n] = arguments[n];\n  }\n\n  return r.reduce(function (t, r) {\n    return function () {\n      return t(r.apply(void 0, arguments));\n    };\n  }, function (t) {\n    return t;\n  });\n},\n    d = function d(t, r) {\n  for (var n = {}, e = 0; e < r.length; e++) {\n    var o = r[e];\n    t.hasOwnProperty(o) && (n[o] = t[o]);\n  }\n\n  return n;\n},\n    O = function O(e, o) {\n  return function (p) {\n    var c = t(p),\n        s = \"function\" == typeof e ? e : function (t, r) {\n      return !i(d(t, e), d(r, e));\n    },\n        v = function (t) {\n      function r() {\n        for (var r, n = arguments.length, e = new Array(n), u = 0; u < n; u++) {\n          e[u] = arguments[u];\n        }\n\n        return (r = t.call.apply(t, [this].concat(e)) || this).state = {\n          computedProps: o(r.props),\n          prevProps: r.props\n        }, r;\n      }\n\n      return f(r, t), r.getDerivedStateFromProps = function (t, r) {\n        return s(r.prevProps, t) ? {\n          computedProps: o(t),\n          prevProps: t\n        } : {\n          prevProps: t\n        };\n      }, r.prototype.render = function () {\n        return c(a({}, this.props, this.state.computedProps));\n      }, r;\n    }(r);\n\n    return n(v), \"production\" !== process.env.NODE_ENV ? u(l(p, \"withPropsOnChange\"))(v) : v;\n  };\n},\n    P = function P(r) {\n  return function (n) {\n    var e = t(n),\n        o = function o(t) {\n      return e(t);\n    };\n\n    return o.defaultProps = r, \"production\" !== process.env.NODE_ENV ? u(l(n, \"defaultProps\"))(o) : o;\n  };\n},\n    N = function N(r) {\n  var n,\n      e = (n = function n(t) {\n    return a({}, t, \"function\" == typeof r ? r(t) : r);\n  }, function (r) {\n    var e = t(r),\n        o = function o(t) {\n      return e(n(t));\n    };\n\n    return \"production\" !== process.env.NODE_ENV ? u(l(r, \"mapProps\"))(o) : o;\n  });\n  return \"production\" !== process.env.NODE_ENV ? function (t) {\n    return u(l(t, \"withProps\"))(e(t));\n  } : e;\n},\n    m = function m(t) {\n  return o(\"propTypes\", t);\n},\n    E = function E(n, e, o) {\n  return function (p) {\n    var c = t(p),\n        i = function (t) {\n      function r() {\n        for (var r, n = arguments.length, e = new Array(n), u = 0; u < n; u++) {\n          e[u] = arguments[u];\n        }\n\n        return (r = t.call.apply(t, [this].concat(e)) || this).state = {\n          stateValue: \"function\" == typeof o ? o(r.props) : o\n        }, r.updateStateValue = function (t, n) {\n          return r.setState(function (r) {\n            var n = r.stateValue;\n            return {\n              stateValue: \"function\" == typeof t ? t(n) : t\n            };\n          }, n);\n        }, r;\n      }\n\n      return f(r, t), r.prototype.render = function () {\n        var t;\n        return c(a({}, this.props, ((t = {})[n] = this.state.stateValue, t[e] = this.updateStateValue, t)));\n      }, r;\n    }(r);\n\n    return \"production\" !== process.env.NODE_ENV ? u(l(p, \"withState\"))(i) : i;\n  };\n};\n\nexport { h as compose, P as defaultProps, e as getDisplayName, y as pure, u as setDisplayName, m as setPropTypes, o as setStatic, i as shallowEqual, v as shouldUpdate, N as withProps, O as withPropsOnChange, E as withState, l as wrapDisplayName };","map":null,"metadata":{},"sourceType":"module"}