{"ast":null,"code":"import _createForOfIteratorHelper from \"/home/system/togo-web-test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\n// Original licensing for the following methods can be found in the\n// NOTICE file in the root directory of this source tree.\n// See https://github.com/calvellido/focus-options-polyfill\n// See https://github.com/adobe/react-spectrum\nimport { getOwnerDocument } from \"./dom\";\nimport { warn } from \"./function\";\nimport { isActiveElement, isInputElement } from \"./tabbable\";\nexport function focus(element, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  var _options = options,\n    _options$isActive = _options.isActive,\n    isActive = _options$isActive === void 0 ? isActiveElement : _options$isActive,\n    nextTick = _options.nextTick,\n    _options$preventScrol = _options.preventScroll,\n    preventScroll = _options$preventScrol === void 0 ? true : _options$preventScrol,\n    _options$selectTextIf = _options.selectTextIfInput,\n    selectTextIfInput = _options$selectTextIf === void 0 ? true : _options$selectTextIf;\n  if (!element || isActive(element)) return -1;\n  function triggerFocus() {\n    if (!element) {\n      warn({\n        condition: true,\n        message: \"[chakra-ui]: can't call focus() on `null` or `undefined` element\"\n      });\n      return;\n    }\n    if (supportsPreventScroll()) {\n      element.focus({\n        preventScroll: preventScroll\n      });\n    } else {\n      element.focus();\n      if (preventScroll) {\n        var scrollableElements = getScrollableElements(element);\n        restoreScrollPosition(scrollableElements);\n      }\n    }\n    if (isInputElement(element) && selectTextIfInput) {\n      element.select();\n    }\n  }\n  if (nextTick) {\n    return requestAnimationFrame(triggerFocus);\n  }\n  triggerFocus();\n  return -1;\n}\nvar supportsPreventScrollCached = null;\nfunction supportsPreventScroll() {\n  if (supportsPreventScrollCached == null) {\n    supportsPreventScrollCached = false;\n    try {\n      var div = document.createElement(\"div\");\n      div.focus({\n        get preventScroll() {\n          supportsPreventScrollCached = true;\n          return true;\n        }\n      });\n    } catch (e) {// Ignore\n    }\n  }\n  return supportsPreventScrollCached;\n}\nfunction getScrollableElements(element) {\n  var _doc$defaultView;\n  var doc = getOwnerDocument(element);\n  var win = (_doc$defaultView = doc.defaultView) != null ? _doc$defaultView : window;\n  var parent = element.parentNode;\n  var scrollableElements = [];\n  var rootScrollingElement = doc.scrollingElement || doc.documentElement;\n  while (parent instanceof win.HTMLElement && parent !== rootScrollingElement) {\n    if (parent.offsetHeight < parent.scrollHeight || parent.offsetWidth < parent.scrollWidth) {\n      scrollableElements.push({\n        element: parent,\n        scrollTop: parent.scrollTop,\n        scrollLeft: parent.scrollLeft\n      });\n    }\n    parent = parent.parentNode;\n  }\n  if (rootScrollingElement instanceof win.HTMLElement) {\n    scrollableElements.push({\n      element: rootScrollingElement,\n      scrollTop: rootScrollingElement.scrollTop,\n      scrollLeft: rootScrollingElement.scrollLeft\n    });\n  }\n  return scrollableElements;\n}\nfunction restoreScrollPosition(scrollableElements) {\n  var _iterator = _createForOfIteratorHelper(scrollableElements),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var _step$value = _step.value,\n        element = _step$value.element,\n        scrollTop = _step$value.scrollTop,\n        scrollLeft = _step$value.scrollLeft;\n      element.scrollTop = scrollTop;\n      element.scrollLeft = scrollLeft;\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n}","map":{"version":3,"names":["getOwnerDocument","warn","isActiveElement","isInputElement","focus","element","options","_options","_options$isActive","isActive","nextTick","_options$preventScrol","preventScroll","_options$selectTextIf","selectTextIfInput","triggerFocus","condition","message","supportsPreventScroll","scrollableElements","getScrollableElements","restoreScrollPosition","select","requestAnimationFrame","supportsPreventScrollCached","div","document","createElement","e","_doc$defaultView","doc","win","defaultView","window","parent","parentNode","rootScrollingElement","scrollingElement","documentElement","HTMLElement","offsetHeight","scrollHeight","offsetWidth","scrollWidth","push","scrollTop","scrollLeft","_iterator","_createForOfIteratorHelper","_step","s","n","done","_step$value","value","err","f"],"sources":["../../src/focus.ts"],"sourcesContent":["// Original licensing for the following methods can be found in the\n// NOTICE file in the root directory of this source tree.\n// See https://github.com/calvellido/focus-options-polyfill\n// See https://github.com/adobe/react-spectrum\n\nimport { getOwnerDocument } from \"./dom\"\nimport { warn } from \"./function\"\nimport { FocusableElement, isActiveElement, isInputElement } from \"./tabbable\"\n\nexport interface ExtendedFocusOptions extends FocusOptions {\n  /**\n   * Function that determines if the element is the active element\n   */\n  isActive?: typeof isActiveElement\n  /**\n   * If true, the element will be focused in the next tick\n   */\n  nextTick?: boolean\n  /**\n   * If true and element is an input element, the input's text will be selected\n   */\n  selectTextIfInput?: boolean\n}\n\nexport function focus(\n  element: FocusableElement | null,\n  options: ExtendedFocusOptions = {},\n) {\n  const {\n    isActive = isActiveElement,\n    nextTick,\n    preventScroll = true,\n    selectTextIfInput = true,\n  } = options\n\n  if (!element || isActive(element)) return -1\n\n  function triggerFocus() {\n    if (!element) {\n      warn({\n        condition: true,\n        message:\n          \"[chakra-ui]: can't call focus() on `null` or `undefined` element\",\n      })\n      return\n    }\n    if (supportsPreventScroll()) {\n      element.focus({ preventScroll })\n    } else {\n      element.focus()\n      if (preventScroll) {\n        const scrollableElements = getScrollableElements(element as HTMLElement)\n        restoreScrollPosition(scrollableElements)\n      }\n    }\n\n    if (isInputElement(element) && selectTextIfInput) {\n      element.select()\n    }\n  }\n\n  if (nextTick) {\n    return requestAnimationFrame(triggerFocus)\n  }\n\n  triggerFocus()\n  return -1\n}\n\nlet supportsPreventScrollCached: boolean | null = null\nfunction supportsPreventScroll() {\n  if (supportsPreventScrollCached == null) {\n    supportsPreventScrollCached = false\n    try {\n      const div = document.createElement(\"div\")\n      div.focus({\n        get preventScroll() {\n          supportsPreventScrollCached = true\n          return true\n        },\n      })\n    } catch (e) {\n      // Ignore\n    }\n  }\n\n  return supportsPreventScrollCached\n}\n\ninterface ScrollableElement {\n  element: HTMLElement\n  scrollTop: number\n  scrollLeft: number\n}\n\nfunction getScrollableElements(element: HTMLElement): ScrollableElement[] {\n  const doc = getOwnerDocument(element)\n  const win = doc.defaultView ?? window\n  let parent = element.parentNode\n  const scrollableElements: ScrollableElement[] = []\n  const rootScrollingElement = doc.scrollingElement || doc.documentElement\n\n  while (parent instanceof win.HTMLElement && parent !== rootScrollingElement) {\n    if (\n      parent.offsetHeight < parent.scrollHeight ||\n      parent.offsetWidth < parent.scrollWidth\n    ) {\n      scrollableElements.push({\n        element: parent,\n        scrollTop: parent.scrollTop,\n        scrollLeft: parent.scrollLeft,\n      })\n    }\n    parent = parent.parentNode\n  }\n\n  if (rootScrollingElement instanceof win.HTMLElement) {\n    scrollableElements.push({\n      element: rootScrollingElement,\n      scrollTop: rootScrollingElement.scrollTop,\n      scrollLeft: rootScrollingElement.scrollLeft,\n    })\n  }\n\n  return scrollableElements\n}\n\nfunction restoreScrollPosition(scrollableElements: ScrollableElement[]) {\n  for (const { element, scrollTop, scrollLeft } of scrollableElements) {\n    element.scrollTop = scrollTop\n    element.scrollLeft = scrollLeft\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}